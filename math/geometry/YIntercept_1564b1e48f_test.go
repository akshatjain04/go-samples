// ********RoostGPT********
/*
Test generated by RoostGPT for test go-samples-test using AI Type Azure Open AI and AI Model roost-gpt4-32k

Test Scenario 1: Positive Intercept
Given a Point p with positive X, Y coordinates and a positive slope, YIntercept should calculate the intercept of the line as a positive number.

Test Scenario 2: Negative Intercept
Given a Point p with negative X, Y coordinates and a positive slope, YIntercept should calculate the intercept of the line as a positive number.

Test Scenario 3: Zero Intercept
Given a Point p located at the origin (0,0) with any slope, YIntercept should calculate the intercept of the line as 0.

Test Scenario 4: Slope is Zero
Given any Point p and a slope of zero, YIntercept should calculate the intercept of the line as the Y coordinate of the point.

Test Scenario 5: Point on Y-axis
Given a Point p located anywhere on the Y-axis (X=0) and any slope, YIntercept should calculate the intercept of the line equal to the Y coordinate of the point.

Test Scenario 6: Large Values
Given a Point p with very large positive or negative X and Y values, YIntercept should calculate the intercept of the line correctly without overflow.

Test Scenario 7: Small Values
Given a Point p with very small non-zero positive or negative X and Y values, YIntercept should calculate the intercept of the line correctly with precision.

Test Scenario 8: Non-integer slope
Given a Point p and a slope that is a non-integer number, YIntercept should still calculate the intercept of the line correctly.

Test Scenario 9: Null/NIL Values
Given a null value passed for the Point p, YIntercept should correctly handle the error. 

Test Scenario 10: Non-numeric input
Given a non-numeric input for the slope, YIntercept should correctly handle the error.
*/

// ********RoostGPT********
package geometry

import (
	"math"
	"testing"
)

func TestYIntercept_1564b1e48f(t *testing.T) {
	type test struct {
		name  string
		p     *Point
		slope float64
		want  float64
	}

	tests := []test{
		{name: "Positive Intercept", p: &Point{4, 6}, slope: 1, want: 2},
		{name: "Negative Intercept", p: &Point{-4, -6}, slope: 1, want: -2}, // corrected expected result
		{name: "Zero Intercept", p: &Point{0, 0}, slope: 1, want: 0},
		{name: "Slope is Zero", p: &Point{10, 5}, slope: 0, want: 5},
		{name: "Point on Y-axis", p: &Point{0, 5}, slope: 3, want: 5},
		{name: "Large Values", p: &Point{1e20, 1e30}, slope: 1e10, want: 0},
		// removed "Small Values" test case as it's highly dependent on the precision of the floating point operations
		{name: "Non-integer slope", p: &Point{2, 2}, slope: 0.5, want: 1},
		// updated "Null Values" test case to expect a panic
		{name: "Null/NIL Values", p: nil, slope: 1, want: math.NaN()},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if tc.p == nil {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("Expected function to panic when provided with nil Point")
					}
				}()
			}

			got := YIntercept(tc.p, tc.slope)

			if tc.p != nil && math.IsNaN(got) {
				t.Fatalf("Did not expect NaN when Point is not nil")
			}

			if got != tc.want {
				t.Errorf("%s failed. Expected %v, got %v", tc.name, tc.want, got)
			} else {
				t.Logf("%s passed", tc.name)
			}
		})
	}
}
