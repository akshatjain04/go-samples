/*
Test generated by RoostGPT for test go-samples-test using AI Type Azure Open AI and AI Model roost-gpt4-32k

1. Test Scenario: Validate if the function `PointDistance` correctly computes the distance of a point from a line represented by the given equation using positive points in the XY plane.

2. Test Scenario: Validate the functionality of the `PointDistance` function when the point lies on the line of the equation.

3. Test Scenario: Ensure the `PointDistance` function correctly handles the coordinates that are negative numbers.

4. Test Scenario: Test the `PointDistance` function with zero coefficients in the line equation to verify if it calculates the distance correctly without causing division by zero error.

5. Test Scenario: Validate the functionality of the `PointDistance` function by using float numbers with decimal points for both point coordinates as well as equation coefficients.

6. Test Scenario: Check the function `PointDistance` with the coefficients of equation as very large numbers. This is to validate if it can handle and return accurate results for large numbers without any overflow errors.

7. Test Scenario: Assess the functionality of the `PointDistance` function in terms of performance by testing it with complex and large number of computations.

8. Test Scenario: Validate if the `PointDistance` function correctly handles when the X and Y coordinates of the point are `NaN` (Not a Number).

9. Test Scenario: Test if `PointDistance` function can handle `nil` point input.

10. Test Scenario: Ensure whether the `PointDistance` function works correctly when called concurrently from multiple goroutines.
*/
package geometry

import (
	"math"
	"sync"
	"testing"
)

func TestPointDistance_f08e35a65d(t *testing.T) {
	scenarios := []struct {
		desc      string
		p         *Point
		equation  [3]float64
		expect    float64
		expectErr bool
	}{
		{
			"Test with positive points in the XY plane",
			&Point{2.0, 3.0},
			[3]float64{1.0, 2.0, 3.0},
			0.6,
			false,
		},
		{
			"Test when point lies on the line of equation",
			&Point{-1.5, 1.0},
			[3]float64{2.0, -2.0, -3.0},
			0.0,
			false,
		},
		{
			"Test with negative coordinates",
			&Point{-2.0, -3.0},
			[3]float64{1.0, 2.0, 3.0},
			2.6,
			false,
		},
		{
			"Test with zero coefficients in the line equation",
			&Point{2.0, 3.0},
			[3]float64{0.0, 0.0, 0.0},
			math.NaN(),
			false,
		},
		{
			"Test with float numbers with decimal points",
			&Point{2.35, 3.56},
			[3]float64{1.23, 2.34, 3.45},
			0.4531166571229761,
			false,
		},
		{
			"Test with large coefficients",
			&Point{2.0, 3.0},
			[3]float64{1e6, 2e6, 3e6},
			1e-06,
			false,
		},
		{
			"Test with NaN coordinates",
			&Point{math.NaN(), math.NaN()},
			[3]float64{1.0, 2.0, 3.0},
			math.NaN(),
			false,
		},
		{
			"Test with nil point input",
			nil,
			[3]float64{1.0, 2.0, 3.0},
			math.NaN(),
			true,
		},
	}

	for _, s := range scenarios {
		t.Run(s.desc, func(t *testing.T) {
			var wg sync.WaitGroup
			for i := 0; i < 1000; i++ {
				wg.Add(1)
				go func() {
					defer wg.Done()

					got := PointDistance(s.p, s.equation)
					if (!s.expectErr && !closeEnough(got, s.expect)) ||
						(s.expectErr && !(math.IsNaN(got) || s.p == nil)) {
						t.Errorf("Expected %v, but got %v", s.expect, got)
					}

					if !s.expectErr && math.IsNaN(got) {
						t.Errorf("NaN value is not expected, but got NaN")
					}

					if s.expectErr && !math.IsNaN(got) {
						t.Errorf("Expected NaN, but got %v", got)
					}
				}()
			}
			wg.Wait()
		})
	}
}

func closeEnough(a, b float64) bool {
	epsilon := 1e-9
	return math.Abs(a-b) <= epsilon*math.Max(math.Abs(a), math.Abs(b))
}
