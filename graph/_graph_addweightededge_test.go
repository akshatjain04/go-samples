// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=AddWeightedEdge_d8cd4eadfe
ROOST_METHOD_SIG_HASH=AddWeightedEdge_b61df28ce0

FUNCTION_DEF=func (g *Graph) AddWeightedEdge(one, two, weight int)
## Test Scenarios for AddWeightedEdge Function

**Scenario 1: Adding an edge to an existing graph**

**Details:**
This test verifies that adding an edge to an existing graph with two nodes updates the graph's edges map correctly.

**Execution:**
* Arrange:
    * Create a new Graph with two vertices.
    * Set the weight of the edge to be added.
* Act:
    * Call AddWeightedEdge with the created vertices and weight.
* Assert:
    * Verify that the weight of the edge is correctly stored in the graph's edges map.

**Validation:**
This test ensures that the AddWeightedEdge function correctly modifies the graph's internal state by adding the specified edge with the correct weight. It is crucial for maintaining the graph's integrity and enabling accurate pathfinding or other graph-related operations.

**Scenario 2: Adding an edge with a weight of 0**

**Details:**
This test checks the behavior of AddWeightedEdge when the weight of the edge is 0.

**Execution:**
* Arrange:
    * Create a new Graph with two vertices.
    * Set the weight of the edge to be added to 0.
* Act:
    * Call AddWeightedEdge with the created vertices and weight.
* Assert:
    * Verify that the weight of the edge is correctly stored as 0 in the graph's edges map.

**Validation:**
This test ensures that the AddWeightedEdge function handles edge weights of 0 correctly, which might be relevant for specific use cases or algorithms that utilize weighted graphs.

**Scenario 3: Adding an edge to a non-existent vertex**

**Details:**
This test checks how AddWeightedEdge behaves when one or both of the provided vertices are not present in the graph.

**Execution:**
* Arrange:
    * Create a new Graph with one vertex.
    * Set the two vertices for the edge to be added, where one is the existing vertex and the other is not present in the graph.
* Act:
    * Call AddWeightedEdge with the created vertices.
* Assert:
    * Verify that the function adds the missing vertex to the graph and then adds the edge with the correct weight.

**Validation:**
This test ensures that the AddWeightedEdge function can handle cases where vertices are dynamically added to the graph, maintaining its consistency and allowing for the addition of edges between existing and new vertices.

**Scenario 4: Adding an edge to an undirected graph**

**Details:**
This test verifies that adding an edge to an undirected graph creates a bidirectional edge with the same weight.

**Execution:**
* Arrange:
    * Create a new undirected Graph with two vertices.
    * Set the weight of the edge to be added.
* Act:
    * Call AddWeightedEdge with the created vertices and weight.
* Assert:
    * Verify that the weight of the edge is correctly stored in both directions (vertex 1 to vertex 2 and vertex 2 to vertex 1) in the graph's edges map.

**Validation:**
This test ensures that the AddWeightedEdge function correctly handles undirected graphs by creating bidirectional edges, which is essential for algorithms and operations that rely on undirected graph properties.

**Scenario 5: Adding an edge to a directed graph**

**Details:**
This test verifies that adding an edge to a directed graph creates a unidirectional edge with the correct weight.

**Execution:**
* Arrange:
    * Create a new directed Graph with two vertices.
    * Set the weight of the edge to be added.
* Act:
    * Call AddWeightedEdge with the created vertices and weight.
* Assert:
    * Verify that the weight of the edge is correctly stored only in the direction specified by the provided vertices (vertex 1 to vertex 2) in the graph's edges map.

**Validation:**
This test ensures that the AddWeightedEdge function correctly handles directed graphs by creating unidirectional edges, which is essential for algorithms and operations that rely on directed graph properties.

**Scenario 6: Adding an edge with duplicate vertices**

**Details:**
This test checks how AddWeightedEdge behaves when both provided vertices are the same.

**Execution:**
* Arrange:
    * Create a new Graph with one vertex.
    * Set both vertices for the edge to be added to the same vertex.
* Act:
    * Call AddWeightedEdge with the created vertices.
* Assert:
    * Verify that the function does not add a self-loop edge to the graph.

**Validation:**
This test ensures that the AddWeightedEdge function handles cases where duplicate vertices are provided, preventing the creation of invalid self-loop edges which could lead to unexpected behavior in graph algorithms or operations.

**These test scenarios cover various aspects of the AddWeightedEdge function, including normal operation, edge cases with different weights and vertex presence, and handling directed and undirected graphs. By covering these scenarios, you can gain confidence in the correctness and robustness of the function under different conditions.**
*/

// ********RoostGPT********
// graph_addweightedge_test.go

package graph

import (
	"testing"
)

func TestGraphAddWeightedEdge(t *testing.T) {
	testCases := []struct {
		name        string
		graph       Graph
		vertices    []int
		weight      int
		expected    Graph
		expectedErr bool
	}{
		{
			name: "Add edge to existing graph",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {1: 10},
				},
				Directed: false,
			},
			vertices: []int{0, 1},
			weight:   20,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {1: 20},
					1: {0: 20},
				},
				Directed: false,
			},
			expectedErr: false,
		},
		{
			name: "Add edge with weight 0",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {1: 10},
				},
				Directed: false,
			},
			vertices: []int{0, 1},
			weight:   0,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {1: 0},
					1: {0: 0},
				},
				Directed: false,
			},
			expectedErr: false,
		},
		{
			name: "Add edge to non-existent vertex",
			graph: Graph{
				vertices: 1,
				edges: map[int]map[int]int{
					0: {},
				},
				Directed: false,
			},
			vertices: []int{0, 2},
			weight:   10,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {2: 10},
					2: {0: 10},
				},
				Directed: false,
			},
			expectedErr: false,
		},
		{
			name: "Add edge to undirected graph",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {},
					1: {},
				},
				Directed: false,
			},
			vertices: []int{0, 1},
			weight:   10,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {1: 10},
					1: {0: 10},
				},
				Directed: false,
			},
			expectedErr: false,
		},
		{
			name: "Add edge to directed graph",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {},
					1: {},
				},
				Directed: true,
			},
			vertices: []int{0, 1},
			weight:   10,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					0: {1: 10},
				},
				Directed: true,
			},
			expectedErr: false,
		},
		{
			name: "Add edge with duplicate vertices",
			graph: Graph{
				vertices: 1,
				edges: map[int]map[int]int{
					0: {},
				},
				Directed: false,
			},
			vertices: []int{0, 0},
			weight:   10,
			expected: Graph{
				vertices: 1,
				edges: map[int]map[int]int{
					0: {},
				},
				Directed: false,
			},
			expectedErr: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := tc.graph.AddWeightedEdge(tc.vertices[0], tc.vertices[1], tc.weight)
			if (err != nil) != tc.expectedErr {
				t.Errorf("Expected error: %t, got: %t, error: %v", tc.expectedErr, err != nil, err)
			}

			if err == nil && !compareGraphs(tc.graph, tc.expected) {
				t.Errorf("Expected graph: %+v, got: %+v", tc.expected, tc.graph)
			}
		})
	}
}

func compareGraphs(g1, g2 Graph) bool {
	if g1.vertices != g2.vertices || g1.Directed != g2.Directed {
		return false
	}

	for v1, edges1 := range g1.edges {
		edges2, ok := g2.edges[v1]
		if !ok {
			return false
		}

		for v2, w1 := range edges1 {
			w2, ok := edges2[v2]
			if !ok || w1 != w2 {
				return false
			}
		}
	}

	return true
}
