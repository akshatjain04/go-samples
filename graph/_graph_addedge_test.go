// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=AddEdge_85c517f422
ROOST_METHOD_SIG_HASH=AddEdge_34af2dc1ea

FUNCTION_DEF=func (g *Graph) AddEdge(one, two int)
## Go Test Scenarios for AddEdge Function

**Package Name:** graph

**Imports:**

```go
// ... other imports ...
import (
	"testing"
)
```

**Function to Test:**

```go
func (g *Graph) AddEdge(one, two int) {
	g.AddWeightedEdge(one, two, 0)
}
```

## Test Scenarios

### Scenario 1: Add Edge to Empty Graph

**Description:** This scenario tests adding an edge to an empty graph.

**Execution:**

- Arrange: Create an empty graph with no vertices or edges.
- Act: Call `AddEdge` with two vertices.
- Assert: Verify that the graph contains the added edge and the weight is 0.

**Validation:**

- This test ensures that the `AddEdge` function correctly adds edges to an empty graph.
- It is important to test this scenario to ensure the graph can be initialized with edges.

### Scenario 2: Add Edge to Existing Graph

**Description:** This scenario tests adding an edge to a graph with existing vertices and edges.

**Execution:**

- Arrange: Create a graph with some vertices and edges.
- Act: Call `AddEdge` with two new vertices.
- Assert: Verify that the graph contains the added edge and the weight is 0.

**Validation:**

- This test ensures that the `AddEdge` function correctly adds edges to a graph with existing vertices.
- It is important to test this scenario to ensure the graph can be dynamically updated with new edges.

### Scenario 3: Add Duplicate Edge

**Description:** This scenario tests adding an edge that already exists in the graph.

**Execution:**

- Arrange: Create a graph with an existing edge between two vertices.
- Act: Call `AddEdge` with the same two vertices.
- Assert: Verify that the graph does not contain a duplicate edge and the weight remains the same.

**Validation:**

- This test ensures that the `AddEdge` function does not add duplicate edges to the graph.
- It is important to test this scenario to prevent the graph from becoming inconsistent.

### Scenario 4: Add Edge with Invalid Vertex

**Description:** This scenario tests adding an edge with an invalid vertex (vertex not present in the graph).

**Execution:**

- Arrange: Create a graph with some vertices and edges.
- Act: Call `AddEdge` with one valid vertex and one invalid vertex.
- Assert: Verify that the function returns an error indicating the invalid vertex.

**Validation:**

- This test ensures that the `AddEdge` function handles invalid vertices correctly.
- It is important to test this scenario to prevent the graph from becoming corrupted.

### Scenario 5: Add Edge to Directed Graph

**Description:** This scenario tests adding an edge to a directed graph.

**Execution:**

- Arrange: Create a directed graph with some vertices and edges.
- Act: Call `AddEdge` with two vertices.
- Assert: Verify that the edge is added in the specified direction and the weight is 0.

**Validation:**

- This test ensures that the `AddEdge` function correctly adds edges to directed graphs, considering the direction.
- It is important to test this scenario to ensure the graph's directed nature is maintained.

These are just a few examples of test scenarios for the `AddEdge` function. You can write more scenarios to cover other edge cases and functionality.

*/

// ********RoostGPT********
package graph

import (
	"testing"
)

func TestGraphAddEdge(t *testing.T) {
	type testCase struct {
		name     string
		graph    Graph
		one, two int
		expected Graph
		err      error
	}

	tests := []testCase{
		{
			name: "Add Edge to Empty Graph",
			graph: Graph{
				vertices: 0,
				edges:    make(map[int]map[int]int),
				Directed: false,
			},
			one: 1,
			two: 2,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
					2: {1: 0},
				},
				Directed: false,
			},
			err: nil,
		},
		{
			name: "Add Edge to Existing Graph",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
				},
				Directed: false,
			},
			one: 3,
			two: 4,
			expected: Graph{
				vertices: 4,
				edges: map[int]map[int]int{
					1: {2: 0},
					2: {1: 0},
					3: {4: 0},
					4: {3: 0},
				},
				Directed: false,
			},
			err: nil,
		},
		{
			name: "Add Duplicate Edge",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
				},
				Directed: false,
			},
			one: 1,
			two: 2,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
				},
				Directed: false,
			},
			err: nil,
		},
		{
			name: "Add Edge with Invalid Vertex",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
				},
				Directed: false,
			},
			one: 3,
			two: 4,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
				},
				Directed: false,
			},
			err: &InvalidVertexError{vertex: 3},
		},
		{
			name: "Add Edge to Directed Graph",
			graph: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
				},
				Directed: true,
			},
			one: 2,
			two: 1,
			expected: Graph{
				vertices: 2,
				edges: map[int]map[int]int{
					1: {2: 0},
					2: {1: 0},
				},
				Directed: true,
			},
			err: nil,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			err := tc.graph.AddEdge(tc.one, tc.two)
			if err != nil {
				if tc.err == nil {
					t.Errorf("Unexpected error: %v", err)
				} else if tc.err.Error() != err.Error() {
					t.Errorf("Expected error: %v, got: %v", tc.err, err)
				}
			} else if tc.err != nil {
				t.Errorf("Expected error: %v, got: nil", tc.err)
			}

			if tc.graph != tc.expected {
				t.Errorf("Expected graph: %v, got: %v", tc.expected, tc.graph)
			}
		})
	}
}
