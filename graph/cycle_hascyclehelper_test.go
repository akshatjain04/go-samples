// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=hasCycleHelper_cb0533a1c6
ROOST_METHOD_SIG_HASH=hasCycleHelper_7ea66715ac

FUNCTION_DEF=func (g Graph) hasCycleHelper(v int, all, visiting, visited map[int]struct) bool
## Test Scenarios for `hasCycleHelper` function

### Scenario 1: No cycle in the graph

**Details:**
This scenario tests the function with a graph that does not contain any cycles. The expected outcome is `false`.

**Execution:**
* Arrange: Create a graph with several vertices and edges, ensuring that there are no cycles.
* Act: Call the `hasCycleHelper` function with a starting vertex.
* Assert: Verify that the function returns `false`.

**Validation:**
This scenario validates the basic functionality of the function and ensures that it correctly identifies graphs without cycles.

### Scenario 2: Cycle present in the graph

**Details:**
This scenario tests the function with a graph that contains a cycle. The expected outcome is `true`.

**Execution:**
* Arrange: Create a graph with a cycle, ensuring that the starting vertex is part of the cycle.
* Act: Call the `hasCycleHelper` function with the starting vertex.
* Assert: Verify that the function returns `true`.

**Validation:**
This scenario validates the function's ability to detect cycles in graphs.

### Scenario 3: Empty graph

**Details:**
This scenario tests the function with an empty graph. The expected outcome is `false`.

**Execution:**
* Arrange: Create an empty graph with no vertices or edges.
* Act: Call the `hasCycleHelper` function with any vertex (as the graph is empty, the vertex choice is irrelevant).
* Assert: Verify that the function returns `false`.

**Validation:**
This scenario ensures that the function handles empty graphs correctly and does not return unexpected results.

### Scenario 4: Starting vertex not present in the graph

**Details:**
This scenario tests the function with a starting vertex that is not present in the graph. The expected outcome is an error.

**Execution:**
* Arrange: Create a graph with several vertices and edges.
* Act: Call the `hasCycleHelper` function with a vertex that is not part of the graph.
* Assert: Verify that the function returns an error indicating the invalid vertex.

**Validation:**
This scenario ensures that the function handles invalid input gracefully and provides appropriate error messages.

### Scenario 5: Handling disconnected components

**Details:**
This scenario tests the function with a graph that has multiple disconnected components. The expected outcome is `false` if the starting vertex is not part of a cycle, and `true` if it is part of a cycle within its component.

**Execution:**
* Arrange: Create a graph with multiple disconnected components, some containing cycles and others not.
* Act: Call the `hasCycleHelper` function with different starting vertices from each component.
* Assert: Verify that the function returns `false` for vertices in components without cycles and `true` for vertices in components with cycles.

**Validation:**
This scenario ensures that the function correctly identifies cycles within individual components of a disconnected graph.

These are just a few examples of test scenarios for the `hasCycleHelper` function. You can create additional scenarios to cover more edge cases and specific functionalities of the function. Remember to consider the provided package name, imports, and struct definitions when designing your test cases.
*/

// ********RoostGPT********
package graph

import (
	"fmt"
	"os"
	"testing"
)

func TestGraphHasCycleHelper(t *testing.T) {
	// Table-driven test cases
	testCases := []struct {
		name     string
		graph    Graph
		start    int
		expected bool
	}{
		{
			name: "No cycle",
			graph: Graph{
				vertices: 5,
				edges: map[int]map[int]int{
					0: {1: 2, 2: 3},
					1: {3: 4},
					2: {},
					3: {},
					4: {},
				},
				Directed: false,
			},
			start:    0,
			expected: false,
		},
		{
			name: "Cycle present",
			graph: Graph{
				vertices: 5,
				edges: map[int]map[int]int{
					0: {1: 2, 2: 3},
					1: {3: 4},
					2: {0: 1},
					3: {},
					4: {},
				},
				Directed: false,
			},
			start:    0,
			expected: true,
		},
		{
			name: "Empty graph",
			graph: Graph{
				vertices: 0,
				edges:    map[int]map[int]int{},
				Directed: false,
			},
			start:    0,
			expected: false,
		},
		{
			name: "Starting vertex not present",
			graph: Graph{
				vertices: 5,
				edges: map[int]map[int]int{
					0: {1: 2, 2: 3},
					1: {3: 4},
					2: {},
					3: {},
					4: {},
				},
				Directed: false,
			},
			start:    5,
			expected: false,
		},
		{
			name: "Disconnected components",
			graph: Graph{
				vertices: 6,
				edges: map[int]map[int]int{
					0: {1: 2},
					1: {0: 1},
					2: {3: 4},
					3: {2: 3},
					4: {},
					5: {},
				},
				Directed: false,
			},
			start:    5,
			expected: false,
		},
		{
			name: "Disconnected components with cycle",
			graph: Graph{
				vertices: 6,
				edges: map[int]map[int]int{
					0: {1: 2},
					1: {0: 1},
					2: {3: 4},
					3: {2: 3, 4: 5},
					4: {3: 4},
					5: {},
				},
				Directed: false,
			},
			start:    3,
			expected: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			fmt.Fprintf(os.Stdout, "Running test case: %s\n", tc.name) // Log scenario

			actual := tc.graph.hasCycleHelper(tc.start, map[int]struct{}{}, map[int]struct{}{}, map[int]struct{}{})
			if actual != tc.expected {
				t.Errorf("Expected %t, got %t", tc.expected, actual)
			} else {
				fmt.Fprintf(os.Stdout, "Test case passed: %s\n", tc.name) // Log success
			}
		})
	}
}
