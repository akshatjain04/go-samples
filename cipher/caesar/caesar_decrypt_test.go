// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=Decrypt_b93746c71b
ROOST_METHOD_SIG_HASH=Decrypt_decfe7d122

FUNCTION_DEF=func Decrypt(input string, key int) string 
Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: go-samples/cipher/caesar/caesar_test.go
Test Cases:
    [Example
    FuzzCaesar
    TestDecrypt]

## Test Scenarios for `Decrypt` function

### Scenario 1: Decrypting a single character

**Details:**
This test checks if the function correctly decrypts a single character using the Caesar cipher.

**Execution:**
```go
func TestDecryptSingleCharacter(t *testing.T) {
  // Arrange
  input := "a"
  key := 3
  expected := "x"

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function correctly shifts the character by the specified key, wrapping around the alphabet if necessary.

### Scenario 2: Decrypting a sentence with a positive key

**Details:**
This test checks if the function correctly decrypts a sentence using the Caesar cipher with a positive key.

**Execution:**
```go
func TestDecryptSentencePositiveKey(t *testing.T) {
  // Arrange
  input := "Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq."
  key := 10
  expected := "The Quick Brown Fox Jumps over the Lazy Dog."

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function correctly shifts each character in the sentence by the specified key, preserving spaces and punctuation.

### Scenario 3: Decrypting a sentence with a negative key

**Details:**
This test checks if the function correctly decrypts a sentence using the Caesar cipher with a negative key.

**Execution:**
```go
func TestDecryptSentenceNegativeKey(t *testing.T) {
  // Arrange
  input := "Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq."
  key := -10
  expected := "The Quick Brown Fox Jumps over the Lazy Dog."

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function correctly handles negative keys by shifting characters in the opposite direction, wrapping around the alphabet if necessary.

### Scenario 4: Decrypting with a key of 0

**Details:**
This test checks if the function returns the original input when the key is 0.

**Execution:**
```go
func TestDecryptKeyZero(t *testing.T) {
  // Arrange
  input := "The Quick Brown Fox Jumps over the Lazy Dog."
  key := 0
  expected := input

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function doesn't modify the input when the key is 0, as a Caesar cipher shift of 0 results in no change.

### Scenario 5: Decrypting with a key exceeding the alphabet size

**Details:**
This test checks if the function correctly handles keys exceeding the alphabet size by wrapping around.

**Execution:**
```go
func TestDecryptKeyExceedingAlphabetSize(t *testing.T) {
  // Arrange
  input := "The Quick Brown Fox Jumps over the Lazy Dog."
  key := 26
  expected := "The Quick Brown Fox Jumps over the Lazy Dog."

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function correctly wraps around the alphabet when the key exceeds its size, resulting in no change to the input.

### Scenario 6: Decrypting an empty string

**Details:**
This test checks if the function correctly handles an empty input string.

**Execution:**
```go
func TestDecryptEmptyString(t *testing.T) {
  // Arrange
  input := ""
  key := 10
  expected := ""

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function returns an empty string when the input is empty, as there is nothing to decrypt.

### Scenario 7: Decrypting a string with non-alphabetic characters

**Details:**
This test checks if the function correctly handles non-alphabetic characters in the input string.

**Execution:**
```go
func TestDecryptNonAlphabeticCharacters(t *testing.T) {
  // Arrange
  input := "The Quick Brown Fox Jumps over the Lazy Dog. 123!@#"
  key := 10
  expected := "The Quick Brown Fox Jumps over the Lazy Dog. 123!@#"

  // Act
  actual := Decrypt(input, key)

  // Assert
  if actual != expected {
    t.Errorf("Expected '%s' but got '%s'", expected, actual)
  }
}
```

**Validation:**
This test ensures that the function leaves non-alphabetic characters unchanged, as the Caesar cipher only applies to letters.

These test scenarios cover various aspects of the `Decrypt` function, including normal operation, edge cases, and error handling. They ensure that the function behaves as expected under different conditions and input values, contributing to the overall quality and reliability of the application. 

*/

// ********RoostGPT********


package caesar

import "testing"







func TestDecrypt(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		key      int
		expected string
	}{
		{
			name:     "DecryptSingleCharacter",
			input:    "a",
			key:      3,
			expected: "x",
		},
		{
			name:     "DecryptSentencePositiveKey",
			input:    "Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq.",
			key:      10,
			expected: "The Quick Brown Fox Jumps over the Lazy Dog.",
		},
		{
			name:     "DecryptSentenceNegativeKey",
			input:    "Dro Aesmu Lbygx Pyh Tewzc yfob dro Vkji Nyq.",
			key:      -10,
			expected: "The Quick Brown Fox Jumps over the Lazy Dog.",
		},
		{
			name:     "DecryptKeyZero",
			input:    "The Quick Brown Fox Jumps over the Lazy Dog.",
			key:      0,
			expected: "The Quick Brown Fox Jumps over the Lazy Dog.",
		},
		{
			name:     "DecryptKeyExceedingAlphabetSize",
			input:    "The Quick Brown Fox Jumps over the Lazy Dog.",
			key:      26,
			expected: "The Quick Brown Fox Jumps over the Lazy Dog.",
		},
		{
			name:     "DecryptEmptyString",
			input:    "",
			key:      10,
			expected: "",
		},
		{
			name:     "DecryptNonAlphabeticCharacters",
			input:    "The Quick Brown Fox Jumps over the Lazy Dog. 123!@#",
			key:      10,
			expected: "The Quick Brown Fox Jumps over the Lazy Dog. 123!@#",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			actual := Decrypt(tt.input, tt.key)
			if actual != tt.expected {
				t.Errorf("Decrypt() = %s, expected %s", actual, tt.expected)
			}
		})
	}
}
