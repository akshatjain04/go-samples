// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=Encrypt_5e2756214b
ROOST_METHOD_SIG_HASH=Encrypt_1a22125b66

FUNCTION_DEF=func Encrypt(key byte, plaintext []byte) []byte
Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: go-samples/cipher/xor/xor_test.go
Test Cases:
    [Example
    FuzzXOR
    TestXorCipherEncrypt]

## Test Scenarios for `Encrypt` Function in `xor` Package

**Scenario 1: Encrypting an empty string**

**Details:**
This test verifies that encrypting an empty string results in an empty byte slice.

**Execution:**
```go
func TestEncryptEmpty(t *testing.T) {
  // Arrange
  key := byte(0)
  plaintext := []byte{}

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  if len(encrypted) != 0 {
    t.Errorf("Expected encrypted text to be empty, got %v", encrypted)
  }
}
```

**Scenario 2: Encrypting a single character string**

**Details:**
This test verifies that encrypting a single character string results in a byte slice with the character XORed with the key.

**Execution:**
```go
func TestEncryptSingleChar(t *testing.T) {
  // Arrange
  key := byte('A')
  plaintext := []byte{'a'}

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  expected := byte('a' ^ 'A')
  if encrypted[0] != expected {
    t.Errorf("Expected encrypted text to be %v, got %v", expected, encrypted[0])
  }
}
```

**Scenario 3: Encrypting a multi-character string**

**Details:**
This test verifies that encrypting a multi-character string results in a byte slice with each character XORed with the key.

**Execution:**
```go
func TestEncryptMultiChar(t *testing.T) {
  // Arrange
  key := byte('K')
  plaintext := []byte("Hello World")

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  for i, ch := range plaintext {
    expected := byte(ch ^ 'K')
    if encrypted[i] != expected {
      t.Errorf("Expected encrypted text at index %d to be %v, got %v", i, expected, encrypted[i])
    }
  }
}
```

**Scenario 4: Encrypting with a zero key**

**Details:**
This test verifies that encrypting with a zero key results in the original plaintext being returned.

**Execution:**
```go
func TestEncryptZeroKey(t *testing.T) {
  // Arrange
  key := byte(0)
  plaintext := []byte("Test String")

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  if !bytes.Equal(encrypted, plaintext) {
    t.Errorf("Expected encrypted text to be equal to plaintext, got %v", encrypted)
  }
}
```

**Scenario 5: Encrypting with a large key**

**Details:**
This test verifies that encrypting with a large key (larger than 255) still results in the correct encryption.

**Execution:**
```go
func TestEncryptLargeKey(t *testing.T) {
  // Arrange
  key := byte(256)
  plaintext := []byte("Large Key Test")

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  for i, ch := range plaintext {
    expected := byte(ch ^ 256)
    if encrypted[i] != expected {
      t.Errorf("Expected encrypted text at index %d to be %v, got %v", i, expected, encrypted[i])
    }
  }
}
```

**Scenario 6: Encrypting with a negative key**

**Details:**
This test verifies that encrypting with a negative key is handled correctly and does not result in unexpected behavior.

**Execution:**
```go
func TestEncryptNegativeKey(t *testing.T) {
  // Arrange
  key := byte(-1)
  plaintext := []byte("Negative Key Test")

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  for i, ch := range plaintext {
    expected := byte(ch ^ 255)
    if encrypted[i] != expected {
      t.Errorf("Expected encrypted text at index %d to be %v, got %v", i, expected, encrypted[i])
    }
  }
}
```

**Scenario 7: Encrypting with a special character key**

**Details:**
This test verifies that encrypting with a special character key (e.g., `!`, `@`, `#`) is handled correctly and does not result in unexpected behavior.

**Execution:**
```go
func TestEncryptSpecialCharKey(t *testing.T) {
  // Arrange
  key := byte('!')
  plaintext := []byte("Special Char Key Test")

  // Act
  encrypted := Encrypt(key, plaintext)

  // Assert
  for i, ch := range plaintext {
    expected := byte(ch ^ '!')
    if encrypted[i] != expected {
      t.Errorf("Expected encrypted text at index %d to be %v, got %v", i, expected, encrypted[i])
    }
  }
}
```

These test scenarios cover a range of normal operation, edge cases, and error handling for the `Encrypt` function. They ensure that the function behaves as expected under different conditions and helps to prevent regressions and unexpected behavior in the future.
*/

// ********RoostGPT********
package xor

import (
	"fmt"
	"os"
	"testing"
)

type testEncryptData struct {
	name        string
	key         byte
	plaintext   string
	expected    string
	expectedErr error
}

func TestEncrypt(t *testing.T) {
	// Table-driven test data
	testCases := []testEncryptData{
		{
			name:        "Encrypt empty string",
			key:         0,
			plaintext:   "",
			expected:    "",
			expectedErr: nil,
		},
		{
			name:        "Encrypt single character string",
			key:         'A',
			plaintext:   "a",
			expected:    "A",
			expectedErr: nil,
		},
		{
			name:        "Encrypt multi-character string",
			key:         'K',
			plaintext:   "Hello World",
			expected:    "Tkkn\x1f\x1d\x1e\x1e",
			expectedErr: nil,
		},
		{
			name:        "Encrypt with zero key",
			key:         0,
			plaintext:   "Test String",
			expected:    "Test String",
			expectedErr: nil,
		},
		{
			name:        "Encrypt with large key",
			key:         255,
			plaintext:   "Large Key Test",
			expected:    "Large Key Test",
			expectedErr: nil,
		},
		{
			name:        "Encrypt with negative key",
			key:         -1,
			plaintext:   "Negative Key Test",
			expected:    "Negative Key Test",
			expectedErr: nil,
		},
		{
			name:        "Encrypt with special character key",
			key:         '!',
			plaintext:   "Special Char Key Test",
			expected:    "Special Char Key Test",
			expectedErr: nil,
		},
	}

	// Run test cases
	for _, testCase := range testCases {
		t.Run(testCase.name, func(t *testing.T) {
			// Capture original output
			origStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			// Perform encryption
			actual, err := Encrypt(testCase.key, []byte(testCase.plaintext))

			// Restore original output
			os.Stdout = origStdout
			_, _ = fmt.Fprintln(w)

			// Validate output
			if err != testCase.expectedErr {
				t.Errorf("Expected error: %v, actual error: %v", testCase.expectedErr, err)
			} else if string(actual) != testCase.expected {
				t.Errorf("Expected encrypted text: %v, actual encrypted text: %v", testCase.expected, string(actual))
			}

			// Log detailed results
			t.Logf("Test case: %s", testCase.name)
			t.Logf("Key: %v, Plaintext: %v", testCase.key, testCase.plaintext)
			t.Logf("Expected: %v, Actual: %v", testCase.expected, string(actual))
			t.Logf("Error: %v", err)
			//t.Logf("Output: %s", strings.TrimSpace(out)) // Commented out as it's not being used
		})
	}
}

func Encrypt(key byte, plaintext []byte) []byte {
	cipherText := []byte{}
	for _, ch := range plaintext {
		cipherText = append(cipherText, key^ch)
	}
	return cipherText
}
