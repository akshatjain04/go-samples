// ********RoostGPT********
/*
Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=isSorted_fa5110ab18
ROOST_METHOD_SIG_HASH=isSorted_ef8018aa66

FUNCTION_DEF=func isSorted[T constraints.Number](arr []T) bool 
Scenario 1: Empty slice

Details:
  Description: The test checks if the function correctly identifies an empty slice as sorted.
Execution:
  Arrange: Define an empty slice of numbers.
  Act: Call the `isSorted` function with the empty slice.
  Assert: Verify that the function returns `true`.
Validation:
  An empty slice should be considered sorted as there are no elements to violate the sorting order. This test ensures that the function handles edge cases correctly.

Scenario 2: Single element slice

Details:
  Description: The test checks if the function correctly identifies a slice with a single element as sorted.
Execution:
  Arrange: Define a slice of numbers with a single element.
  Act: Call the `isSorted` function with the single-element slice.
  Assert: Verify that the function returns `true`.
Validation:
  A single element slice should be considered sorted as there are no other elements to compare it with. This test verifies that the function behaves correctly with minimal input.

Scenario 3: Sorted slice with multiple elements

Details:
  Description: The test verifies that the function identifies a properly sorted slice with multiple elements as sorted.
Execution:
  Arrange: Define a sorted slice of numbers with more than one element.
  Act: Call the `isSorted` function with the sorted slice.
  Assert: Verify that the function returns `true`.
Validation:
  The function should return `true` for a sorted array. This test validates the primary functionality of the function for typical use cases.

Scenario 4: Unsorted slice with multiple elements

Details:
  Description: The test ensures that the function detects an unsorted slice with multiple elements.
Execution:
  Arrange: Define an unsorted slice of numbers.
  Act: Call the `isSorted` function with the unsorted slice.
  Assert: Verify that the function returns `false`.
Validation:
  The function should return `false` for an unsorted array. This scenario checks that the function can correctly identify a violation of the sorting condition.

Scenario 5: Large sorted slice

Details:
  Description: The test checks the function's performance and correctness on a large sorted slice.
Execution:
  Arrange: Generate a large sorted slice of random numbers.
  Act: Call the `isSorted` function with the large sorted slice.
  Assert: Verify that the function returns `true`.
Validation:
  Testing with a large data set ensures that the function performs as expected under a higher load and that there are no issues with memory or processing time.

Scenario 6: Large unsorted slice

Details:
  Description: The test checks the function's ability to handle a large unsorted slice.
Execution:
  Arrange: Generate a large unsorted slice of random numbers.
  Act: Call the `isSorted` function with the large unsorted slice.
  Assert: Verify that the function returns `false`.
Validation:
  Similar to the previous scenario, this test ensures the function can handle large data sets. It's important to check that the function doesn't incorrectly identify a large unsorted array as sorted.

Scenario 7: Slice with duplicate elements

Details:
  Description: The test verifies that the function treats slices with duplicate elements as sorted.
Execution:
  Arrange: Define a sorted slice of numbers with duplicate elements.
  Act: Call the `isSorted` function with the slice.
  Assert: Verify that the function returns `true`.
Validation:
  A sorted slice may contain duplicate elements, and the function should still return `true`. This test ensures that duplicates are handled correctly.

Scenario 8: Slice with negative and positive numbers

Details:
  Description: The test checks if the function correctly identifies a sorted slice containing both negative and positive numbers.
Execution:
  Arrange: Define a sorted slice with mixed negative and positive numbers.
  Act: Call the `isSorted` function with the mixed slice.
  Assert: Verify that the function returns `true`.
Validation:
  The sorting order should accommodate slices with mixed positive and negative elements. This scenario ensures that the function can handle such cases.

Scenario 9: Slice with maximum and minimum values

Details:
  Description: The test ensures the function handles slices containing the maximum and minimum possible values for the number type.
Execution:
  Arrange: Define a slice containing the extremes of the number type's range.
  Act: Call the `isSorted` function with the extreme values slice.
  Assert: Verify that the function returns `true` or `false` based on the order.
Validation:
  This scenario tests the function's ability to handle the edge cases of the number type's range and ensures that it doesn't result in overflow or underflow issues.

Scenario 10: Slice with non-number type

Details:
  Description: The test checks the function's response when provided with a slice of a non-number type.
Execution:
  Arrange: Define a slice of a non-number type, such as strings.
  Act: Attempt to call the `isSorted` function with the non-number slice.
  Assert: Compile-time error is expected.
Validation:
  The function is constrained to number types, and this scenario ensures that the type constraint is enforced at compile-time, preventing misuse of the function.
*/

// ********RoostGPT********


package sort

import (
	"math/rand"
	"testing"
	"time"
	"github.com/TheAlgorithms/Go/constraints"
)







func TestIsSorted(t *testing.T) {

	rand.Seed(time.Now().UnixNano())

	tests := []struct {
		name     string
		input    []int
		expected bool
	}{
		{
			name:     "Empty slice",
			input:    []int{},
			expected: true,
		},
		{
			name:     "Single element slice",
			input:    []int{1},
			expected: true,
		},
		{
			name:     "Sorted slice with multiple elements",
			input:    []int{1, 2, 3, 4, 5},
			expected: true,
		},
		{
			name:     "Unsorted slice with multiple elements",
			input:    []int{5, 3, 4, 1, 2},
			expected: false,
		},
		{
			name:     "Large sorted slice",
			input:    generateSortedSlice(1000),
			expected: true,
		},
		{
			name:     "Large unsorted slice",
			input:    generateUnsortedSlice(1000),
			expected: false,
		},
		{
			name:     "Slice with duplicate elements",
			input:    []int{1, 2, 2, 3, 4, 4, 5},
			expected: true,
		},
		{
			name:     "Slice with negative and positive numbers",
			input:    []int{-3, -2, -1, 0, 1, 2, 3},
			expected: true,
		},
		{
			name:     "Slice with maximum and minimum values",
			input:    []int{constraints.MinInt, 0, constraints.MaxInt},
			expected: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := isSorted(tc.input)
			if result != tc.expected {
				t.Errorf("Test %s failed: expected %v, got %v", tc.name, tc.expected, result)
			} else {
				t.Logf("Test %s passed", tc.name)
			}
		})
	}
}
func generateSortedSlice(size int) []int {
	slice := make([]int, size)
	for i := range slice {
		slice[i] = i
	}
	return slice
}
func generateUnsortedSlice(size int) []int {
	slice := make([]int, size)
	for i := range slice {
		slice[i] = rand.Intn(size)
	}
	return slice
}
