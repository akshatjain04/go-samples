// ********RoostGPT********
/*
Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=isSorted_fa5110ab18
ROOST_METHOD_SIG_HASH=isSorted_ef8018aa66

FUNCTION_DEF=func isSorted[T constraints.Number](arr []T) bool 
Scenario 1: Empty slice

Details:
  Description: The test checks if the function correctly identifies an empty slice as sorted.
Execution:
  Arrange: Define an empty slice of numbers.
  Act: Invoke the `isSorted` function with the empty slice.
  Assert: The function should return `true` because an empty slice is considered sorted by definition.
Validation:
  An empty slice does not contain any elements to be out of order, so the function should always return `true`. This test validates the function's behavior for cases when there is no data to sort.

Scenario 2: Single element slice

Details:
  Description: The test checks if the function correctly identifies a single-element slice as sorted.
Execution:
  Arrange: Define a slice with only one number element.
  Act: Invoke the `isSorted` function with the single-element slice.
  Assert: The function should return `true` since a single-element slice is trivially sorted.
Validation:
  A single-element slice cannot be out of order, so the function should always return `true`. This test ensures that the function handles trivial cases correctly.

Scenario 3: Already sorted multiple elements

Details:
  Description: The test verifies that the function returns `true` for a slice that is already sorted in ascending order.
Execution:
  Arrange: Define a slice with multiple numbers in ascending order.
  Act: Invoke the `isSorted` function with the sorted slice.
  Assert: The function should return `true` because the elements are in non-decreasing order.
Validation:
  This test checks the primary functionality of the function, ensuring it recognizes a sorted sequence. This is fundamental to the function's purpose.

Scenario 4: Not sorted multiple elements

Details:
  Description: The test checks if the function identifies a slice that is not sorted.
Execution:
  Arrange: Define a slice with numbers not in ascending order.
  Act: Invoke the `isSorted` function with the unsorted slice.
  Assert: The function should return `false` because the elements are not in non-decreasing order.
Validation:
  The test ensures that the function can detect when a sequence is out of order, which is crucial for the function's validity.

Scenario 5: Large slice with random elements

Details:
  Description: The test checks the function's performance and correctness on a large slice with random elements.
Execution:
  Arrange: Generate a large slice with random numbers using the `rand` package.
  Act: Invoke the `isSorted` function with the random slice.
  Assert: Manually sort the slice and compare the result with the `isSorted` function output to ensure correctness.
Validation:
  This test is important for performance benchmarking and ensuring the function scales well with input size. It also checks for correctness in a more complex scenario.

Scenario 6: Slice with duplicate elements

Details:
  Description: The test checks if the function correctly identifies a sorted slice containing duplicate elements.
Execution:
  Arrange: Define a slice with multiple numbers in non-decreasing order, including duplicates.
  Act: Invoke the `isSorted` function with the slice containing duplicates.
  Assert: The function should return `true` as duplicates do not violate the sorted property.
Validation:
  The test ensures that the function handles the presence of duplicate elements correctly. In sorted order, duplicates are allowed and should not be considered unsorted.

Scenario 7: Slice with negative and positive elements

Details:
  Description: The test checks if the function correctly identifies a sorted slice containing both negative and positive numbers.
Execution:
  Arrange: Define a slice with negative and positive numbers in non-decreasing order.
  Act: Invoke the `isSorted` function with the mixed slice.
  Assert: The function should return `true` as the mixed elements are in sorted order.
Validation:
  This test ensures that the function handles numbers with different signs and validates that the sorting logic is not affected by the sign of the numbers.

Scenario 8: Slice with maximum and minimum values

Details:
  Description: The test checks if the function correctly identifies a sorted slice containing the maximum and minimum possible values for the number type.
Execution:
  Arrange: Define a slice with the minimum and maximum values for the type `T`.
  Act: Invoke the `isSorted` function with this slice.
  Assert: The function should return `true` if the values are in non-decreasing order.
Validation:
  This test verifies boundary value analysis, ensuring the function handles extreme values without errors or incorrect behavior. It is crucial for the robustness of the function.
*/

// ********RoostGPT********


package sort

import (
	"math/rand"
	"reflect"
	"sort"
	"testing"
	"time"
)







func TestIsSorted(t *testing.T) {

	rand.Seed(time.Now().UnixNano())

	testCases := []struct {
		name     string
		input    []int
		expected bool
	}{
		{
			name:     "Empty slice",
			input:    []int{},
			expected: true,
		},
		{
			name:     "Single element slice",
			input:    []int{42},
			expected: true,
		},
		{
			name:     "Already sorted multiple elements",
			input:    []int{1, 2, 3, 4, 5},
			expected: true,
		},
		{
			name:     "Not sorted multiple elements",
			input:    []int{5, 3, 1, 2, 4},
			expected: false,
		},
		{
			name:     "Large slice with random elements",
			input:    rand.Perm(1000),
			expected: false,
		},
		{
			name:     "Slice with duplicate elements",
			input:    []int{1, 2, 2, 3, 3},
			expected: true,
		},
		{
			name:     "Slice with negative and positive elements",
			input:    []int{-5, -3, 0, 1, 2},
			expected: true,
		},
		{
			name:     "Slice with maximum and minimum values",
			input:    []int{int(^uint(0) >> 1), int(^uint(0) << 63)},
			expected: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			result := isSorted(tc.input)

			if result != tc.expected {
				t.Errorf("isSorted(%v) = %v, expected %v", tc.input, result, tc.expected)
			} else {
				t.Logf("isSorted(%v) = %v, as expected", tc.input, result)
			}
		})
	}
}
