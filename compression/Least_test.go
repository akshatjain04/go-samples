// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

Scenario 1: Test with empty parameters

Details:
Description: This test will check the behavior of the function when both parameters are empty. The function should return zero values for Node, and two empty slices []Node.

Execution:
Arrange: No required data
Act: Invoke the least function with two empty slice parameters []Node{} and []Node{}.
Assert: The Node returned should be of zero values, and both output slice should be empty.

Validation:
The assertion will verify that the function can handle empty parameters and return appropriate zero values. This check is important to ensure the function is robust and well-adapted to different input scenarios.

Scenario 2: One queue has elements, the other is empty

Details:
Description: This test scenario verifies that the function can correctly return the first element of one queue when the other input queue is empty.

Execution:
Arrange: Make one queue with a single Node, and another empty queue.
Act: Invoke the least function with these two queues.
Assert: The returned Node should be the first (and only) Node in the non-empty queue, and the non-empty queue that is returned should be empty, while the other queue remains empty.

Validation:
This scenario will validate that the function correctly handles a situation where one queue has Nodes and the other does not. It ensures that the function correctly prioritizes a non-empty queue and successfully takes a Node from it.

Scenario 3: Both queues are populated, first 'q1' queue's top node has lesser weight

Details:
Description: This test scenario verifies the function properly compares the weight of the top nodes of both queues and returns the node with lesser weight.

Execution:
Arrange: Prepare two queues, ensuring that the first Node in 'q1' has a lesser weight than the first node in 'q2'.
Act: Invoke the least function with these two queues.
Assert: The returned Node should be the first Node in 'q1', and the returned 'q1' should have its first Node removed, while 'q2' stays the same.

Validation:
The test scenario confirms functionalities around weight comparison and queue priority. The quality of the logic in this method is critical for accurate handling and sorting of Nodes based on weights in the main application.

Scenario 4: Both queues are populated, second 'q2' queue's top node is lesser or equal weight

Details:
Description: This test scenario is almost similar to the third one, but tests the function's ability to return the top node from 'q2' when it has least or equal weight than 'q1' top node.

Execution:
Arrange: Prepare two queues, ensuring that the first Node in 'q2' has a lesser or equal weight than the first node in 'q1'.
Act: Invoke the least function with these two queues.
Assert: The returned Node should be the first Node in 'q2', and the returned 'q2' should have its first Node removed, while 'q1' stays the same.

Validation:
This scenario verifies that the function correctly handles and prefers 'q2' when weights are equal, ensuring proper order and balance in the queue processing system.
*/

// ********RoostGPT********
package compression

import (
	"fmt"
	"reflect"
	"testing"
)

func TestLeast(t *testing.T) {
	testCases := []struct {
		name     string
		q1       []*Node
		q2       []*Node
		wantNode *Node
		wantQ1   []*Node
		wantQ2   []*Node
	}{
		{
			name: "Scenario 1: Test with empty parameters",
			q1:   []*Node{},
			q2:   []*Node{},
			wantNode: &Node{},
			wantQ1:   []*Node{},
			wantQ2:   []*Node{},
		},
		{
			name:     "Scenario 2: One queue has elements, the other is empty",
			q1:       []*Node{{symbol: 'A', weight: 1}},
			q2:       []*Node{},
			wantNode: &Node{symbol: 'A', weight: 1},
			wantQ1:   []*Node{},
			wantQ2:   []*Node{},
		},
		{
			name:     "Scenario 3: Both queues are populated, first 'q1' queue's top node has lesser weight",
			q1:       []*Node{{symbol: 'A', weight: 1}, {symbol: 'B', weight: 2}},
			q2:       []*Node{{symbol: 'C', weight: 3}, {symbol: 'D', weight: 4}},
			wantNode: &Node{symbol: 'A', weight: 1},
			wantQ1:   []*Node{{symbol: 'B', weight: 2}},
			wantQ2:   []*Node{{symbol: 'C', weight: 3}, {symbol: 'D', weight: 4}},
		},
		{
			name:     "Scenario 4: Both queues are populated, second 'q2' queue's top node is lesser or equal weight",
			q1:       []*Node{{symbol: 'A', weight: 3}, {symbol: 'B', weight: 4}},
			q2:       []*Node{{symbol: 'C', weight: 1}, {symbol: 'D', weight: 2}},
			wantNode: &Node{symbol: 'C', weight: 1},
			wantQ1:   []*Node{{symbol: 'A', weight: 3}, {symbol: 'B', weight: 4}},
			wantQ2:   []*Node{{symbol: 'D', weight: 2}},
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			gotNode, gotQ1, gotQ2 := least(tc.q1, tc.q2)
			
			if !reflect.DeepEqual(tc.wantNode, gotNode) {
				t.Errorf("Unexpected Node: want %v, got %v ", tc.wantNode, gotNode)
			}
			
			if !reflect.DeepEqual(tc.wantQ1, gotQ1) {
				t.Errorf("Unexpected 'q1': want %v, got %v ", tc.wantQ1, gotQ1)
			}
			
			if !reflect.DeepEqual(tc.wantQ2, gotQ2) {
				t.Errorf("Unexpected 'q2': want %v, got %v ", tc.wantQ2, gotQ2)
			}
		})
	}
}
