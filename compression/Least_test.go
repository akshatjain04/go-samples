// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

Scenario 1: When both input slices are empty
  Details:
    Description: This test is meant to check the behavior of the function when both the input slices are empty. An index out of range error is expected as the function tries to access elements at index 0.
  Execution:
    Arrange: Define two empty Node slices, q1 and q2.
    Act: Invoke the least function with the two empty slices.
    Assert: The test should check that an index out of range panic is thrown.
  Validation:
    The assertion checks that an index out of range panic is thrown when both input slices are empty, as the function would try to access elements that do not exist.

Scenario 2: When only the first input slice is empty
  Details:
    Description: This test is meant to check the behavior of the function when only the first input slice is empty. The function is expected to return the first element of the second slice.
  Execution:
    Arrange: Define an empty Node slice, q1, and a Node slice, q2, containing some elements.
    Act: Invoke the least function with the two slices.
    Assert: The function should return the first element of q2. 
  Validation: 
    The function defines that if q1 is empty, return the first element of q2. Therefore, the test validates this by providing q1 as an empty slice and q2 as a populated slice.

Scenario 3: When only the second input slice is empty
  Details:
    Description: This test is meant to check the behavior of the function when only the second slice is empty. The function is expected to return the first element of the first slice.
  Execution:
    Arrange: Define a Node slice, q1 containing some elements, and an empty Node slice, q2.
    Act: Invoke the least function with the two slices.
    Assert: The function should return the first element of q1.
  Validation: 
    The function defines that if q2 is empty, return the first element of q1. Therefore, the test validates this by providing q2 as an empty slice and q1 as a populated slice.

Scenario 4: Both slices contain elements, and the first element of q1 has less weight
  Details:
    Description: This test checks if the function correctly compares the weights of the first elements in the input slices and returns the one with less weight, specifically when the element in q1 has less weight.
  Execution:
    Arrange: Create two Node slices, q1 and q2, with some elements, ensuring that the first in q1 has less weight than the first in q2.
    Act: Invoke the least function with the two slices.
    Assert: Assert that the function returns the first element of q1 and that the rest of q1 and q2 are unchanged.
  Validation: 
    The test validates the correct handling of predefined weights by the function and ensures that the weight comparison function operates as expected.

Scenario 5: Both slices contain elements, and the first element of q2 has less weight
  Details:
    Description: Similar to the previous test, but this time it is checked if the function returns the first element of q2 when it has less weight.
  Execution:
    Arrange: Create two Node slices, q1 and q2, with some elements, ensuring that the first in q2 has less weight than the first in q1.
    Act: Invoke the least function with the two slices.
    Assert: Assert that the function returns the first element of q2 and the state that the rest of q1 and q2 are untouched.
  Validation: 
    The test verifies the correct handling of predefined weights by the function and ensures that the weight comparison logic operates as expected.
*/

// ********RoostGPT********
package compression

import (
	"fmt"
	"testing"
)

func TestLeast(t *testing.T) {
	// Define test table
	tests := []struct {
		name string
		q1   []Node
		q2   []Node
		want Node
	}{
		{"Both slices are empty", []Node{}, []Node{}, Node{nil, nil, 0, 0}},
		{"First slice is empty", []Node{}, []Node{{nil, nil, 'a', 1}}, Node{nil, nil,'a', 1}},
		{"Second slice is empty", []Node{{nil, nil,'a', 1}}, []Node{}, Node{nil, nil,'a', 1}},
		{"Both slices have elements, q1's first element has less weight", []Node{{nil, nil,'a', 1}}, []Node{{nil, nil,'b', 2}}, Node{nil, nil,'a', 1}},
		{"Both slices have elements, q2's first element has less weight", []Node{{nil, nil,'a', 2}}, []Node{{nil, nil,'b', 1}}, Node{nil, nil,'b', 1}},
	}

	// Iterate through test table
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, _, _ := least(tt.q1, tt.q2)
			// Check if result matches expectation
			if got != tt.want {
				t.Errorf("least() = %v, want %v", got, tt.want)
			}
		})
	}
}
