// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

Scenario 1: Test When Both Input Lists Are Non-Empty and the Weight Of the First Node of `q1` Is Less Than Or Equal To That Of `q2`

Details:
    Description: This test scenario validates whether the `least` function correctly returns a node with the smallest weight when both `q1` and `q2` are not empty and the weight of the first node of `q1` is less than or equal to that of `q2`.
Execution:
    Arrange: Prepare two lists of nodes 'q1' and 'q2' such that they are not empty and the weight of the first node in 'q1' is less than or equal to that of 'q2'.
    Act: Call the `least` function with 'q1' and 'q2' as arguments.
    Assert: Ensure that the returned node is the first node in q1, and the updated q1 and q2 are as expected.
Validation:
    The assertion is checking if the weight of the returned node is the least weight among the first nodes of the two queues. It also checks whether the remaining nodes in both queues are correct. The test is necessary to ensure that the `least` function is functioning as expected in normal cases.


Scenario 2: Test When Both Input Lists Are Non-Empty and the Weight Of the First Node of `q1` Is Greater Than That Of `q2`

Details:
    Description: This test scenario validates whether the `least` function correctly returns a node with the smallest weight when both `q1` and `q2` are not empty and the weight of the first node of `q1` is greater than that of `q2`.
Execution:
    Arrange: Prepare two lists of nodes 'q1' and 'q2' such that they are not empty and the weight of the first node in 'q1' is greater than that of 'q2'.
    Act: Call the `least` function with 'q1' and 'q2' as arguments.
    Assert: Ensure that the returned node is the first node in q2, and the updated q1 and q2 are as expected.
Validation:
    The assertion is checking if the weight of the returned node is the least weight among the first nodes of the two queues. It also checks whether the remaining nodes in both queues are correct. This is necessary for correctness in situations when 'q1' does not have the node with the least weight.

Scenario 3: Test When One of the Input Lists Is Empty

Details:
    Description: This test scenario checks whether the `least` function works correctly in the edge case where either 'q1' or 'q2' is empty.
Execution:
    Arrange: Set one list of nodes to be empty and the other one non-empty.
    Act: Call the `least` function with these two lists as parameters.
    Assert: Check if the returned node is the first node of the non-empty queue and the remaining nodes are correct.
Validation:
    The assertion is checking if the least function correctly handles the situation when one of the lists is empty. This is crucial for the robustness of the function, as it ensures that it doesn't fail when such edge circumstances occur.

Scenario 4: Test When Both Input Lists Are Empty

Details:
    Description: This test scenario focuses on an extreme edge case where both 'q1' and 'q2' are empty.
Execution:
    Arrange: Set both 'q1' and 'q2' to be empty lists.
    Act: Call the `least` function with these two lists as parameters.
    Assert: Depending on the function's expected response to empty input, this could result in an error, or some predefined response.
Validation:
    The function is not expected to handle this case correctly. The assertion would check whether the function returns an error or a special return value indicating an unsuccessful operation. This is important because it verifies whether the code can handle exceptional situations and provide meaningful feedback.
*/

// ********RoostGPT********
package compression

import (
	"reflect"
	"testing"
)

func TestLeast(t *testing.T) {

	// defining table for table-driven test
	tests := []struct {
		name     string
		q1       []Node
		q2       []Node
		expected Node
		q1Update []Node
		q2Update []Node
	}{
		{
			name: "Both queues are non-empty and q1's weight < q2's weight",
			q1:   []Node{{weight: 1}, {weight: 2}},
			q2:   []Node{{weight: 3}, {weight: 4}},
			expected:    Node{weight: 1},
			q1Update: []Node{{weight: 2}},
			q2Update: []Node{{weight: 3}, {weight: 4}},
		},
		{
			name: "Both queues are non-empty and q1's weight > q2's weight",
			q1:   []Node{{weight: 3}, {weight: 4}},
			q2:   []Node{{weight: 1}, {weight: 2}},
			expected:    Node{weight: 1},
			q1Update: []Node{{weight: 3}, {weight: 4}},
			q2Update: []Node{{weight: 2}},
		},
		{
			name: "q1 is empty",
			q1:   []Node{},
			q2:   []Node{{weight: 1}, {weight: 2}},
			expected:    Node{weight: 1},
			q1Update: []Node{},
			q2Update: []Node{{weight: 2}},
		},
        	{
			name: "q2 is empty",
			q1:   []Node{{weight: 1}, {weight: 2}},
			q2:   []Node{},
			expected:    Node{weight: 1},
			q1Update: []Node{{weight: 2}},
			q2Update: []Node{},
		},
		{
			name: "Both queues are empty",
			q1:   []Node{},
			q2:   []Node{},
			expected:    Node{},
			q1Update: []Node{},
			q2Update: []Node{},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			result, q1, q2 := least(test.q1, test.q2)
			if !reflect.DeepEqual(result, test.expected) {
				t.Errorf("least() = %v, expected %v", result, test.expected)
			}
			if !reflect.DeepEqual(q1, test.q1Update) {
				t.Errorf("q1 after operation = %v, expected %v", q1, test.q1Update)
			}
			if !reflect.DeepEqual(q2, test.q2Update) {
				t.Errorf("q2 after operation = %v, expected %v", q2, test.q2Update)
			}
		})
	}

}
