// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

Scenario 1: Normal operation with q1 having the least weight

Details:
Description: This test is meant to check the normal operation of the function where q1[0] has the least weight. It covers the condition where q1[0].weight <= q2[0].weight is true.
Execution:
Arrange: Create two slices of Node q1 and q2 where q1[0] has the least weight.
Act: Invoke the least(q1, q2) function.
Assert: Check if the returned node is equal to q1[0] and the remainder of the slices are correct.
Validation:
The assertion checks the return value of the function and the impact on the input slices. This test is important to validate that the function correctly retrieves the element with the least weight from the input slices when q1[0] has the least weight.


Scenario 2: Normal operation with q2 having the least weight

Details:
Description: This test is meant to check the normal operation of the function where q2[0] has the least weight. It covers the condition where q1[0].weight <= q2[0].weight is false.
Execution:
Arrange: Create two slices of Node q1 and q2 where q2[0] has the least weight.
Act: Invoke the least(q1, q2) function.
Assert: Check if the returned node is equal to q2[0] and the remainder of the slices are correct.
Validation:
The assertion checks the return value of the function and the impact on the input slices. This test is important to validate that the function correctly retrieves the element with the least weight from the input slices when q2[0] has the least weight.


Scenario 3: Edge case with q1 being empty

Details:
Description: This test is meant to check the behavior of the function when q1 is empty. It covers the condition where len(q1) == 0, thus testing the function's ability to handle edge cases.
Execution:
Arrange: Create two slices of Node where q1 is empty.
Act: Invoke the least(q1, q2) function.
Assert: Check if the returned node is equal to q2[0] and the remainder of the slices are correct.
Validation:
The assertion checks the return value of the function and the impact on the input slices. This test is important to validate that the function correctly handles the scenario when q1 is empty.


Scenario 4: Edge case with q2 being empty

Details:
Description: This test is meant to check the behavior of the function when q2 is empty. It covers the condition where len(q2) == 0, thus testing the function's ability to handle edge cases.
Execution:
Arrange: Create two slices of Node where q2 is empty.
Act: Invoke the least(q1, q2) function.
Assert: Check if the returned node is equal to q1[0] and the remainder of the slices are correct.
Validation:
The assertion checks the return value of the function and the impact on the input slices. This test is important to validate that the function correctly handles the scenario when q2 is empty.


Scenario 5: Edge case with both q1 and q2 being empty

Details:
Description: This test is meant to check the behavior of the function when both q1 and q2 are empty. It covers the condition where both len(q1) == 0 and len(q2) == 0, thus testing the function's ability to handle edge cases.
Execution:
Arrange: Create two empty slices of Node.
Act: Invoke the least(q1, q2) function.
Assert: Check if function returns an error or handles the situation gracefully.
Validation:
The assertion checks the function's behavior in exceptional scenarios. This test is important to validate that the function gracefully handles the scenario when both input slices are empty.
*/

// ********RoostGPT********
package compression

import (
	"reflect"
	"testing"
)

func TestLeast(t *testing.T) {

	// test scenarios
	tests := []struct {
		name       string
		q1         []Node
		q2         []Node
		want       Node
		wantQ1     []Node
		wantQ2     []Node
	}{
		{
			"Normal operation with q1 having the least weight",
			[]Node{{weight: 1}, {weight: 2}},
			[]Node{{weight: 2}, {weight: 3}},
			Node{weight: 1},
			[]Node{{weight: 2}},
			[]Node{{weight: 2}, {weight: 3}},
		},
		{
			"Normal operation with q2 having the least weight",
			[]Node{{weight: 2}, {weight: 3}},
			[]Node{{weight: 1}, {weight: 2}},
			Node{weight: 1},
			[]Node{{weight: 2}, {weight: 3}},
			[]Node{{weight: 2}},
		},
		{
			"Edge case with q1 being empty",
			[]Node{},
			[]Node{{weight: 1}, {weight: 2}},
			Node{weight: 1},
			[]Node{},
			[]Node{{weight: 2}},
		},
		{
			"Edge case with q2 being empty",
			[]Node{{weight: 1}, {weight: 2}},
			[]Node{},
			Node{weight: 1},
			[]Node{{weight: 2}},
			[]Node{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotQ1, gotQ2 := least(tt.q1, tt.q2)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("least() got = %v, want = %v", got, tt.want)
			}
			if !reflect.DeepEqual(gotQ1, tt.wantQ1) {
				t.Errorf("least() gotQ1 = %v, wantQ1 = %v", gotQ1, tt.wantQ1)
			}
			if !reflect.DeepEqual(gotQ2, tt.wantQ2) {
				t.Errorf("least() gotQ2 = %v, wantQ2 = %v", gotQ2, tt.wantQ2)
			}
		})
	}
}
