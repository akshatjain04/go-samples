// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

Scenario 1: Both queues are not empty and first node of first queue has the least weight.

Details:
  Description: This test will verify that the function returns the node with the least weight when both queues have elements, and the node with the least weight is the first one in the first queue.
Execution:
  Arrange: Create two queues with nodes, make sure the first node from the first queue has the smallest weight among all nodes.
  Act: Call the function with the two queues as parameters.
  Assert: Check that the returned node is the first element of the first queue, and the rest of that queue and the second queue are returned as they are.
Validation:
  The assertion tests if the method correctly recognizes and returns the node with the least weight. The test is important because it validates the normal operation of the function.

Scenario 2: Both queues are not empty and first node of second queue has the least weight.

Details:
  Description: This test will verify that the function is able to identify the smallest weighted node from the second queue when both queues have nodes.
Execution:
  Arrange: Create two queues with nodes, make sure the first one from the second queue has the smallest weight among all nodes.
  Act: Call the function with the two queues as parameters.
  Assert: Confirm that the returned node is the first element of the second queue, and the remaining nodes of that queue and the first queue are returned as they are.
Validation:
  This assertion validates that the function can correctly identify and return the smallest weighted node from either queue, ensuring the function's proper operation in different scenarios.

Scenario 3: First Queue is Empty.

Details:
  Description: Test to verify that the function returns the first node from the second queue when the first queue is empty.
Execution:
  Arrange: Create one queue with nodes and one empty queue.
  Act: Call the function with both queues.
  Assert: Check that the returned node is the first one of the second queue, and the rest of the second queue are returned along with an empty first queue.
Validation:
  The assertion checks that if the first queue is empty, the function can return the first node from the second queue. This covers an edge case that is essential to handle in many real-world scenarios.

Scenario 4: Second Queue is Empty.

Details:
  Description: This test will verify that the function returns the first node from the first queue when the second queue is empty.
Execution:
  Arrange: Create one queue with nodes and one empty queue.
  Act: Call the function with both queues but in reverse order.
  Assert: Check that the returned node is the first node of the first queue, along with the rest of the first queue and an empty second queue.
Validation:
  The assertion validates that if the second queue is empty, the function can still select the first node from the first queue. This scenario covers another edge case, ensuring proper function behavior in various conditions.

Scenario 5: Both Queues are Empty.

Details:
  Description: This test will verify that the function can handle the case where both queues are empty without throwing errors.
Execution:
  Arrange: Create two empty queues.
  Act: Call the function with both queues.
  Assert: Handle any errors or panics that may occur. Check that appropriate values are returned.
Validation:
  The handling of errors or panics and confirming appropriate return values validates that the function behaves as expected even when both queues are empty. This test scenario is important as it checks the function's error handling impact on the entire application.

*/

// ********RoostGPT********
package compression

import (
	"reflect"
	"testing"
)

func TestLeast(t *testing.T) {

  var testCases = []struct {
		name         string
		q1           []Node
		q2           []Node
		expectedNode Node
		expectedQ1   []Node
		expectedQ2   []Node
	}{
		{
			name: "Scenario 1: Both queues are not empty and the first node of the first queue has the least weight",
			q1:   []Node{{weight: 2}, {weight: 3}},
			q2:   []Node{{weight: 4}, {weight: 5}},
			expectedNode: Node{weight: 2},
			expectedQ1: []Node{{weight: 3}},
			expectedQ2: []Node{{weight: 4}, {weight: 5}},
		},
		{
			name: "Scenario 2: Both queues are not empty and the first node of second queue has the least weight",
			q1:   []Node{{weight: 6}, {weight: 7}},
			q2:   []Node{{weight: 5}, {weight: 8}},
			expectedNode: Node{weight: 5},
			expectedQ1: []Node{{weight: 6}, {weight: 7}},
			expectedQ2: []Node{{weight: 8}},
		},
		{
			name: "Scenario 3: First queue is empty",
			q1:   []Node{},
			q2:   []Node{{weight: 9}, {weight: 10}},
			expectedNode: Node{weight: 9},
			expectedQ1: []Node{},
			expectedQ2: []Node{{weight: 10}},
		},
		{
			name: "Scenario 4: Second queue is empty",
			q1:   []Node{{weight: 11}, {weight: 12}},
			q2:   []Node{},
			expectedNode: Node{weight: 11},
			expectedQ1: []Node{{weight: 12}},
			expectedQ2: []Node{},
		},
		{
			name: "Scenario 5: Both queues are empty",
			q1:   []Node{},
			q2:   []Node{},
			expectedNode: Node{},
			expectedQ1: []Node{},
			expectedQ2: []Node{},
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {

		  resultNode, resultQ1, resultQ2 := least(tt.q1, tt.q2)

		  if !reflect.DeepEqual(resultNode, tt.expectedNode) || !reflect.DeepEqual(resultQ1, tt.expectedQ1) || !reflect.DeepEqual(resultQ2, tt.expectedQ2) {
			t.Errorf("Test %s failed: got node %v, Q1 %v, Q2 %v, expected node %v, Q1 %v, Q2 %v", tt.name,
				resultNode, resultQ1, resultQ2, tt.expectedNode, tt.expectedQ1, tt.expectedQ2)
		  }
		})
	}
}
