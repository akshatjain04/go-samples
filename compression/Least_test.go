// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

- Scenario 1: Least function with both q1 and q2 containing nodes

  Details:
    Description: This test is meant to check the functionality of "least" function when both input slices q1 and q2 have nodes.
  Execution:
    Arrange: Create two slices of Nodes with variable weights.
    Act: Invoke the "least" function with the two Node slicess.
    Assert: Check if the function returns the Node with the least weight from the two input slides and the remaining nodes from their respective slices.
  Validation:
    The expected result should be the Node with the least weight from the two input slices. This test is important to verify the basic functionality of the "least" function.

- Scenario 2: Least function with q1 empty and q2 containing nodes

  Details:
    Description: This test is meant to check how the "least" function behaves when the first input slice q1 is empty.
  Execution:
    Arrange: Create a slice of Nodes for q2 and leave q1 empty.
    Act: Invoke the "least" function with an empty slice q1 and a non-empty slice q2.
    Assert: Check if the function returns the first Node in q2 and the remaining nodes in q2.
  Validation:
    The expected result should be the first Node in q2. This test is important to verify the "least" function's behavior when one of the input slices is empty.

- Scenario 3: Least function with q2 empty and q1 containing nodes

  Details:
    Description: This test is meant to check how the "least" function behaves when the second input slice q2 is empty.
  Execution:
    Arrange: Create a slice of Nodes for q1 and leave q2 empty.
    Act: Invoke the "least" function with a non-empty slice q1 and an empty slice q2.
    Assert: Check if the function returns the first Node in q1 and the remaining nodes in q1.
  Validation:
    The expected result should be the first Node in q1. This test is important to verify the "least" function's behavior when one of the input slices is empty.

- Scenario 4: Least function with both q1 and q2 empty 

  Details:
    Description: This test is meant to check the "least" function's behavior when both input slices are empty.
  Execution:
    Arrange: Keep both input slices q1 and q2 empty.
    Act: Invoke the "least" function with both empty slices.
    Assert: Check if the function handles this scenario without crashing and what does it return.
  Validation:
    This scenario would ideally never occur in a normal application function. However, in a test scenario, it checks how well the function handles unexpected inputs, verifying the function's robustness.
*/

// ********RoostGPT********
package compression

import (
	"reflect"
	"testing"
)
 
func TestLeast(t *testing.T) {
	// Define test cases
	testCases := []struct {
		name       string
		q1         []Node
		q2         []Node
		wantNode   Node
		wantQ1     []Node
		wantQ2     []Node
	}{
		{
			name:     "Scenario 1: both q1 and q2 containing nodes",
			q1:       []Node{{weight: 5}, {weight: 10}, {weight: 15}},
			q2:       []Node{{weight: 4}, {weight: 20}, {weight: 25}},
			wantNode: Node{weight: 4},
			wantQ1:   []Node{{weight: 5}, {weight: 10}, {weight: 15}},
			wantQ2:   []Node{{weight: 20}, {weight: 25}},
		},
		{
			name:     "Scenario 2: q1 empty and q2 containing nodes",
			q1:       []Node{},
			q2:       []Node{{weight: 4}, {weight: 20}, {weight: 25}},
			wantNode: Node{weight: 4},
			wantQ1:   []Node{},
			wantQ2:   []Node{{weight: 20}, {weight: 25}},
		},
		{
			name:     "Scenario 3: q2 empty and q1 containing nodes",
			q1:       []Node{{weight: 5}, {weight: 10}, {weight: 15}},
			q2:       []Node{},
			wantNode: Node{weight: 5},
			wantQ1:   []Node{{weight: 10}, {weight: 15}},
			wantQ2:   []Node{},
		},
		{
			name:     "Scenario 4: both q1 and q2 empty",
			q1:       []Node{},
			q2:       []Node{},
			wantNode: Node{},
			wantQ1:   []Node{},
			wantQ2:   []Node{},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			gotNode, gotQ1, gotQ2 := least(tc.q1, tc.q2)

			if !reflect.DeepEqual(gotNode, tc.wantNode) {
				t.Errorf("Expected node %v, but got node %v", tc.wantNode, gotNode)
			}

			if !reflect.DeepEqual(gotQ1, tc.wantQ1) {
				t.Errorf("Expected q1 %v, but got q1 %v", tc.wantQ1, gotQ1)
			}

			if !reflect.DeepEqual(gotQ2, tc.wantQ2) {
				t.Errorf("Expected q2 %v, but got q2 %v", tc.wantQ2, gotQ2)
			}
		})
	}
}
