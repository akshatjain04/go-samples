// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=least_a3eb2b15d7
ROOST_METHOD_SIG_HASH=least_288573aa58

Scenario 1: Input arrays q1 and q2 are not empty and the first node of q1 has least weight
```
Details:
  Description: This test validates that the function correctly picks the node with the least weight from the first position of either array q1 or q2 when both arrays contain nodes. In this scenario, the node in the first position of the q1 array has the least weight.
Execution:
  Arrange: Create two arrays of 'Node' type where the least weighted node resides at the first position of q1.
  Act: Call the 'least' function with the two arrays as parameters.
  Assert: Verify that the function correctly returns the least weighted node (i.e., the first node of q1), reduced q1 (q1 without the first node) and unchanged q2.
Validation:
  The assertion was chosen to validate that the function correctly identifies and returns the least weighted node among the first nodes of both arrays. This test is important as it guarantees that our function operates as expected under normal conditions.
```

Scenario 2: Input arrays q1 and q2 are not empty and the first node of q2 has least weight
```
Details:
  Description: Similar to the previous scenario, this test validates that the function correctly picks the node with the least weight from the first position of either array q1 or q2 when both arrays contain nodes. In this scenario, the node in the first position of the q2 array has the least weight.
Execution:
  Arrange: Create two arrays of 'Node' type where the least weighted node resides at the first position of q2.
  Act: Call the 'least' function with the two arrays as parameters.
  Assert: Verify that the function correctly returns the least weighted node (i.e., the first node of q2), unchanged q1 and reduced q2 (q2 without the first node). 
Validation:
  This scenario validates whether the function can accurately identify and return the node with the least weight from the first position of the arrays. This test is crucial for normal operation handling of the algorithm.
```

Scenario 3: Input array q1 is empty and q2 is not empty 
```
Details:
  Description: This tests the scenario where the first array (q1) is empty, and the second array (q2) has nodes. The function should be capable of dealing with this edge case and correctly return the first node of the second array.
Execution:
  Arrange: Create an empty q1 array and a non-empty q2 array of 'Node' type.
  Act: Call the 'least' function with the two arrays as parameters.
  Assert: Verify that the function correctly returns the first node of q2, unchanged empty q1 and reduced q2.
Validation:
  This test affirms whether the function can handle edge cases where one of the input arrays is empty. It ensures robustness in cases of missing or incomplete data. 
```

Scenario 4: Input array q2 is empty and q1 is not empty 
```
Details:
  Description: This tests the scenario where the second array (q2) is empty, and the first array (q1) has nodes. The function should be able to handle this edge case and correctly return the first node of the first array.
Execution:
  Arrange: Create a non-empty q1 array and an empty q2 array of 'Node' type.
  Act: Call the 'least' function with the two arrays as parameters.
  Assert: Verify that the function correctly returns the first node of q1, reduced q1 and unchanged empty q2.
Validation:
  This scenario validates if the function can handle edge cases where one of the input arrays is empty. It's crucial for ensuring the function's robustness in the face of missing or incomplete data. 
```
*/

// ********RoostGPT********
package compression

import (
	"reflect"
	"testing"
)

func TestLeast(t *testing.T) {
	// Test data creation
	node1 := Node{symbol: 'a', weight: 1}
	node2 := Node{symbol: 'b', weight: 2}
	node3 := Node{symbol: 'c', weight: 3}
	node4 := Node{symbol: 'd', weight: 4}

	testCases := []struct {
		name	string
		q1	[]Node
		q2	[]Node
		expectedLeastNode Node
		expectedQ1 []Node
		expectedQ2 []Node
	}{
		{
			name: "Test scenario 1: q1 and q2 are not empty, first position of q1 has least weight", 
			q1: []Node{node1, node2}, 
			q2: []Node{node3, node4}, 
			expectedLeastNode: node1,
			expectedQ1: []Node{node2},
			expectedQ2: []Node{node3, node4},
		},
		{
			name: "Test scenario 2: q1 and q2 are not empty, first position of q2 has least weight",
			q1: []Node{node3, node4}, 
			q2: []Node{node1, node2}, 
			expectedLeastNode: node1,
			expectedQ1: []Node{node3, node4},
			expectedQ2: []Node{node2},
		},
		{
			name: "Test scenario 3: q1 is empty, q2 is not empty",
			q1: []Node{}, 
			q2: []Node{node1, node2}, 
			expectedLeastNode: node1,
			expectedQ1: []Node{},
			expectedQ2: []Node{node2},
		},
		{
			name: "Test scenario 4: q2 is empty, q1 is not empty",
			q1: []Node{node1, node2}, 
			q2: []Node{}, 
			expectedLeastNode: node1,
			expectedQ1: []Node{node2},
			expectedQ2: []Node{},
		},
	}

	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			leastNode, newQ1, newQ2 := least(tt.q1, tt.q2)

			// Compare the results
			if !reflect.DeepEqual(leastNode, tt.expectedLeastNode) {
				t.Errorf("got %v, want %v", leastNode, tt.expectedLeastNode)
			}
			
			if !reflect.DeepEqual(newQ1, tt.expectedQ1) {
				t.Errorf("got Q1: %v, want Q1: %v", newQ1, tt.expectedQ1)
			}
			
			if !reflect.DeepEqual(newQ2, tt.expectedQ2) {
				t.Errorf("got Q2: %v, want Q2: %v", newQ2, tt.expectedQ2)
			}
		})
	}
}
