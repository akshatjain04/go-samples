// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=HuffEncoding_ac77adcbe4
ROOST_METHOD_SIG_HASH=HuffEncoding_6d6c7bee1c

Scenario 1: Huffman Encoding for a Single Character Node

Details:
  Description: This test would check the case where the given node is a leaf node i.e., containing a specific character. This test checks if the encoding for a single character is being properly set.
Execution:
  Arrange: Instantiate a `Node` with a valid symbol, a `prefix` slice of booleans and an empty `codes` map.
  Act: Invoke HuffEncoding with the initialized Node, prefix, and map.
  Assert: Confirm that the Node's symbol is key mapped to the provided boolean prefix in the codes map.
Validation:
  The assertion validates that HuffEncoding correctly adds single characters to the codes map. A correct implementation is crucial to complete Huffman Encoding, especially for texts of minimal length.

Scenario 2: Huffman Encoding for Non-Character Node

Details:
  Description: This test is meant to check Huffman encoding for non-character nodes, i.e., intermediate nodes which don't carry a symbol, but have left and right child nodes.
Execution:
  Arrange: Prepare a parent `Node` with two child nodes each carrying a different symbol. Provide an empty boolean slice and a `codes` map for encoding the input.
  Act: Invoke HuffEncoding with the parent Node, an empty prefix and codes map.
  Assert: Check that the codes map has two entries with relevant prefixes.
Validation:
  The assertion helps confirm that HuffEncoding correctly traverses through non-character nodes and encodes each symbol, a critical operation for Huffman encoding trees with more than one node.

Scenario 3: Huffman Encoding of a Complete Huffman Tree

Details:
  Description: This test will verify that HuffEncoding handles a complete Huffman tree, traversing through all nodes and correctly encoding every character.
Execution:
  Arrange: Prepare a Huffman tree with multiple nodes where each node can be a character or non-character node. Initialize a prefix and the codes map.
  Act: Call HuffEncoding with the root node of the Huffman tree, an empty prefix, and the codes map.
  Assert: Demonstrate that the codes map contains the correct prefix for every character within the Huffman tree.
Validation:
  The validity of Huffman Encoding greatly relies on correctly providing unique Huffman codes for every unique character within the complete Huffman tree. This test thus ensures that all characters are encoded without omission.

Scenario 4: Invalid Input to the Huffman Encoding function

Details:
  Description: This test checks how HuffEncoding handles a null Node.
Execution:
  Arrange: Initialize a nil Node, an empty prefix and an empty codes map.
  Act: Call HuffEncoding with a nil Node, an empty prefix, and an empty codes map.
  Assert: Neither panic occurs nor changes made to the codes map.
Validation:
  In real scenarios, the input node might be unintentionally uninitialized i.e., nil, which would result in a nil pointer dereference error. Avoiding panic and handling it gracefully is essential for robust software, making this test important.
*/

// ********RoostGPT********
package compression

import (
	"reflect"
	"testing"
)

func TestHuffEncoding(t *testing.T) {
	tests := []struct {
		name       string
		root       *Node
		wantPrefix map[rune][]bool
	}{
		{
			name: "Scenario 1: Huffman Encoding for a Single Character Node",
			root: &Node{
				symbol: 'a',
				weight: 1,
				left:   nil,
				right:  nil,
			},
			wantPrefix: map[rune][]bool{'a': {}},
			
		},
		{
			name: "Scenario 2: Huffman Encoding for Non-Character Node",
			root: &Node{
				left: &Node{
					symbol: 'b',
					weight: 2,
					left:   nil,
					right:  nil,
				},
				right: &Node{
					symbol: 'c',
					weight: 3,
					left:   nil,
					right:  nil,
				},
			},
			wantPrefix: map[rune][]bool{'b': {false}, 'c': {true}},
		},
		{
			name: "Scenario 3: Huffman Encoding of a Complete Huffman Tree",
			root: &Node{
				left: &Node{
					symbol: 'b',
					weight: 2,
					left:   nil,
					right:  nil,
				},
				right: &Node{
					left: &Node{
						symbol: 'a',
						weight: 1,
						left:   nil,
						right:  nil,
					},
					right: &Node{
						symbol: 'c',
						weight: 3,
						left:   nil,
						right:  nil,
					},
				},
			},
			wantPrefix: map[rune][]bool{'b': {false}, 'c': {true, true}, 'a': {true, false}},
		},
		{
			name:       "Scenario 4: Invalid Input to the Huffman Encoding function",
			root:       nil,
			wantPrefix: map[rune][]bool{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			prefix := []bool{}
			codes := make(map[rune][]bool)
			defer func() {
				if r := recover(); r != nil {
					t.Fatalf("HuffEncoding panic for nil node.")
				}
			}()
			HuffEncoding(tt.root, prefix, codes)
			if !reflect.DeepEqual(tt.wantPrefix, codes) {
				t.Errorf("HuffEncoding() got = %v, want = %v", codes, tt.wantPrefix)
			}
		})
	}
}
