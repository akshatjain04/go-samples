// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=HuffEncoding_ac77adcbe4
ROOST_METHOD_SIG_HASH=HuffEncoding_6d6c7bee1c

Scenario 1: Valid Node with Single Symbol

Details:
Description: This test checks if the function correctly generates Huffman codes for a node containing a single symbol with no child nodes.
Execution:
Arrange: Construct a Node with a single symbol and weight, symbol being not -1 and no child nodes.
Act: Call the HuffEncoding function with the created Node, a pre-defined prefix, and a new map to store the generated codes.
Assert: Verify that the map of codes contains only one entry for the symbol from the Node with the correct prefix.
Validation:
The assertion verifies that the function behaves as expected when operating on a simple single-symbol node. This is important to confirm basic functionality and correctness of the algorithm.

Scenario 2: Valid Node with Multiple Symbols / Child Nodes

Details:
Description: This test is meant to check if the function correctly generates the Huffman codes for a node containing multiple symbols in its child nodes.
Execution:
Arrange: Construct a Node tree where the root has two child nodes, each containing different symbols.
Act: Call the HuffEncoding function with the root Node, an empty prefix, and a new map to store the codes.
Assert: Verify that the map of codes contains entries for each of the child node's symbols with different correct prefixes.
Validation:
The assertion validates that the function works when operating on Nodes with child nodes and correctly decides on prefix values. Confirming this aspect is essential for the entire functionality of the Huffman Encoding process.

Scenario 3: Node with Negative Symbol Value

Details:
Description: This test checks if the function tries to add a negative symbol to the codes map as negative symbols should be ignored.
Execution:
Arrange: Construct a root Node with a negative symbol and no child nodes.
Act: Call the HuffEncoding function with the root Node, an empty prefix, and a new map to store generated codes.
Assert: Verify that the codes map is empty after the function call.
Validation:
The assertion ensures that the function behaves correctly when encountering nodes with negative symbol values, which is supposed to be ignored according to the Huffman Encoding logic. It validates the condition 'node.symbol != -1' and its correct implementation in the function.

Scenario 4: Node with nil Child Nodes

Details:
Description: This test checks for the function's behavior when it is called with a node containing nil child nodes.
Execution:
Arrange: Construct a root Node with two nil child nodes and non-negative symbol.
Act: Call the HuffEncoding function with a defined root Node, an empty prefix, and a new map to store the codes.
Assert: Verify that the map of codes contains only entry for the root node's symbol with the proper prefix.
  Validation:
The assertion verifies that the function behaves as expected for nodes with nil child nodes, adding their symbols to the codes map. This is necessary to ensure proper handling of edge cases, which prevents potential runtime errors or invalid encoding.
*/

// ********RoostGPT********
package compression

import (
	"testing"
	"reflect"
)

func TestHuffEncoding(t *testing.T) {
    tests := []struct {
        name   string
        node   *Node
        prefix []bool
        want   map[rune][]bool
    }{
        {
            name: "Valid Node with Single Symbol",
            node: &Node{symbol: 'a', weight: 1},
            prefix: []bool{},
            want: map[rune][]bool{'a': []bool{}},
        },
        {
            name: "Valid Node with Multiple Symbols / Child Nodes",
            node: &Node{
                left: &Node{symbol: 'a', weight: 1},
                right: &Node{symbol: 'b', weight: 1},
                weight: 2,
            },
            prefix: []bool{},
            want: map[rune][]bool{'a': []bool{false}, 'b': []bool{true}},
        },
        {
            name: "Node with Negative Symbol Value",
            node: &Node{symbol: -1, weight: 1},
            prefix: []bool{},
            want: map[rune][]bool{},
        },
        {
            name: "Node with nil Child Nodes",
            node: &Node{symbol: 'a', weight: 1, left: nil, right: nil},
            prefix: []bool{},
            want: map[rune][]bool{'a': []bool{}},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := make(map[rune][]bool)
            HuffEncoding(tt.node, tt.prefix, got)
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("HuffEncoding() = %v, want %v", got, tt.want)
            }
        })
    }
}
