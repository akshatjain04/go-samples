// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=LpsDp_59828f2314
ROOST_METHOD_SIG_HASH=LpsDp_5ec61b788a

FUNCTION_DEF=func LpsDp(word string) int 
## Test Scenarios for LpsDp Function

### Scenario 1: Empty String

**Description:** Test the function with an empty string as input.

**Details:**

- Arrange: Create an empty string `word`.
- Act: Call the function `LpsDp(word)`.
- Assert: Verify that the function returns 0.

**Validation:**

- An empty string has no longest palindromic substring, so the expected result is 0.
- This test ensures that the function handles empty inputs correctly.

### Scenario 2: Single Character String

**Description:** Test the function with a single character string as input.

**Details:**

- Arrange: Create a string with a single character `word`.
- Act: Call the function `LpsDp(word)`.
- Assert: Verify that the function returns 1.

**Validation:**

- A single character string is always a palindrome, so the expected result is 1.
- This test ensures that the function handles single-character inputs correctly.

### Scenario 3: Palindrome String

**Description:** Test the function with a palindrome string as input.

**Details:**

- Arrange: Create a palindrome string `word`.
- Act: Call the function `LpsDp(word)`.
- Assert: Verify that the function returns the length of the string.

**Validation:**

- The entire string is a palindrome, so the expected result is the length of the string.
- This test ensures that the function correctly identifies palindromes.

### Scenario 4: Non-Palindrome String

**Description:** Test the function with a non-palindrome string as input.

**Details:**

- Arrange: Create a non-palindrome string `word`.
- Act: Call the function `LpsDp(word)`.
- Assert: Verify that the function returns the length of the longest palindromic substring.

**Validation:**

- The function should correctly identify the longest palindromic substring within the non-palindrome string.
- This test ensures that the function works correctly for non-palindrome inputs.

### Scenario 5: Large String

**Description:** Test the function with a large string as input.

**Details:**

- Arrange: Create a large string `word`.
- Act: Call the function `LpsDp(word)`.
- Assert: Verify that the function returns the correct result within a reasonable time.

**Validation:**

- This test ensures that the function scales well for large inputs and does not take an excessive amount of time to execute.

### Scenario 6: Special Characters

**Description:** Test the function with a string containing special characters.

**Details:**

- Arrange: Create a string containing special characters `word`.
- Act: Call the function `LpsDp(word)`.
- Assert: Verify that the function ignores special characters and correctly identifies the longest palindromic substring.

**Validation:**

- This test ensures that the function handles special characters correctly and does not treat them as part of the palindrome.

### Scenario 7: Boundary Cases

**Description:** Test the function with boundary cases, such as strings with lengths 0, 1, and 2.

**Details:**

- Arrange: Create strings with lengths 0, 1, and 2.
- Act: Call the function `LpsDp(word)` for each string.
- Assert: Verify that the function returns the correct results for each case.

**Validation:**

- This test ensures that the function handles boundary cases correctly and does not exhibit unexpected behavior.

These scenarios cover a wide range of input possibilities and should help ensure that the `LpsDp` function is working correctly.
*/

// ********RoostGPT********


package dynamic

import "testing"







func TestLpsDp(t *testing.T) {
	tests := []struct {
		name string
		word string
		want int
	}{
		{
			name: "Empty string",
			word: "",
			want: 0,
		},
		{
			name: "Single character string",
			word: "a",
			want: 1,
		},
		{
			name: "Palindrome string",
			word: "racecar",
			want: 7,
		},
		{
			name: "Non-palindrome string",
			word: "banana",
			want: 3,
		},
		{
			name: "Large string",
			word: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
			want: 15,
		},
		{
			name: "Special characters",
			word: "!@#$%^&*()_+",
			want: 1,
		},
		{
			name: "Boundary cases",
			word: "a",
			want: 1,
		},
		{
			name: "Boundary cases",
			word: "aa",
			want: 2,
		},
		{
			name: "Boundary cases",
			word: "aba",
			want: 3,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := LpsDp(tt.word); got != tt.want {
				t.Errorf("LpsDp() = %v, want %v", got, tt.want)
			}
		})
	}
}
