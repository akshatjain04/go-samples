// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=NthFibonacci_c1b030cc26
ROOST_METHOD_SIG_HASH=NthFibonacci_87ebddc103

FUNCTION_DEF=func NthFibonacci(n uint) uint
Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: go-samples/dynamic/fibonacci_test.go
Test Cases:
    [Test_NthFibonacci]

## Test Scenarios for NthFibonacci function

**Scenario 1: Calculate the first Fibonacci number (0th)**

Details:
Description: This test verifies that the function correctly returns 0 for the 0th Fibonacci number.
Execution:
Arrange: None
Act: Call NthFibonacci(0)
Assert: Assert that the result is equal to 0.
Validation:
This test ensures that the base case of the recursive function is handled correctly.

**Scenario 2: Calculate the second Fibonacci number (1st)**

Details:
Description: This test verifies that the function correctly returns 1 for the 1st Fibonacci number.
Execution:
Arrange: None
Act: Call NthFibonacci(1)
Assert: Assert that the result is equal to 1.
Validation:
This test ensures that the function correctly handles the second base case.

**Scenario 3: Calculate the 10th Fibonacci number**

Details:
Description: This test verifies that the function correctly calculates the 10th Fibonacci number (55).
Execution:
Arrange: None
Act: Call NthFibonacci(10)
Assert: Assert that the result is equal to 55.
Validation:
This test validates the function's ability to handle larger Fibonacci numbers.

**Scenario 4: Calculate the 50th Fibonacci number**

Details:
Description: This test verifies that the function correctly calculates the 50th Fibonacci number (12586269025).
Execution:
Arrange: None
Act: Call NthFibonacci(50)
Assert: Assert that the result is equal to 12586269025.
Validation:
This test further validates the function's ability to handle even larger Fibonacci numbers.

**Scenario 5: Handle negative input**

Details:
Description: This test verifies that the function returns an error when a negative input is provided.
Execution:
Arrange: None
Act: Call NthFibonacci(-1)
Assert: Assert that the function returns an error.
Validation:
This test ensures that the function handles invalid input gracefully.

**Scenario 6: Handle overflow conditions**

Details:
Description: This test verifies that the function handles potential overflow conditions when calculating large Fibonacci numbers.
Execution:
Arrange: None
Act: Call NthFibonacci(100)
Assert: Assert that the function returns the correct result without overflow.
Validation:
This test ensures that the function is robust and can handle large numbers without errors.

**Scenario 7: Compare performance with alternative implementations**

Details:
Description: This test compares the performance of the function with other known implementations of the Fibonacci sequence.
Execution:
Arrange: Implement or obtain alternative Fibonacci implementations.
Act: Time the execution of each implementation for calculating large Fibonacci numbers.
Assert: Compare the execution times and analyze the performance differences.
Validation:
This test helps identify potential optimizations and ensures the function's efficiency.

These scenarios cover various aspects of the NthFibonacci function, including normal operation, edge cases, and error handling. They also consider performance and alternative implementations. Additional scenarios can be created to further explore the function's behavior and robustness.
*/

// ********RoostGPT********
package dynamic

import (
	"testing"
)

func TestNthFibonacci(t *testing.T) {
	type testCase struct {
		name   string
		input  uint
		output uint
	}

	testCases := []testCase{
		{
			name:   "Test 0th Fibonacci number",
			input:  0,
			output: 0,
		},
		{
			name:   "Test 1st Fibonacci number",
			input:  1,
			output: 1,
		},
		{
			name:   "Test 10th Fibonacci number",
			input:  10,
			output: 55,
		},
		{
			name:   "Test 50th Fibonacci number",
			input:  50,
			output: 12586269025,
		},
		{
			name:   "Test negative input",
			input:  -1,
			output: 0,
		},
		{
			name:   "Test overflow conditions",
			input:  100,
			output: 0,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Logf("Input: %d", tc.input)
			result := NthFibonacci(tc.input)
			t.Logf("Output: %d", result)

			if result != tc.output {
				t.Errorf("Expected %d, got %d", tc.output, result)
			}
		})
	}
}

func NthFibonacci(n uint) uint {
	if n == 0 {
		return 0
	}

	var n1, n2 uint = 0, 1

	for i := uint(1); i < n; i++ {
		n3 := n1 + n2
		n1 = n2
		n2 = n3
	}

	return n2
}
