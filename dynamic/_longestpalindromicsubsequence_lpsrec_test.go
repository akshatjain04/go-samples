// ********RoostGPT********
/*
Test generated by RoostGPT for test amanVertexAI20th using AI Type Vertex AI and AI Model gemini-pro

ROOST_METHOD_HASH=LpsRec_aa5de908b5
ROOST_METHOD_SIG_HASH=LpsRec_df85ba8776

FUNCTION_DEF=func LpsRec(word string) int
## Test Scenarios for LpsRec Function

**Package Name:** dynamic

**Imports:**

```go
import (
	"testing"
)
```

**Defined Constants:**

```go
// No defined constants
```

**Defined Vars:**

```go
// No defined vars
```

**Function to Test:**

```go
func LpsRec(word string) int {
	return lpsRec(word, 0, len(word)-1)
}

func lpsRec(word string, low, high int) int {
	if low > high {
		return 0
	}
	if low == high {
		return 1
	}
	if word[low] == word[high] {
		return 2 + lpsRec(word, low+1, high-1)
	}
	return max(lpsRec(word, low+1, high), lpsRec(word, low, high-1))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## Test Scenarios

### Scenario 1: Empty String

**Details:**

* Description: Check if the function handles an empty string input correctly.
* Target scenario: The function should return 0 for an empty string.

**Execution:**

* Arrange: Create an empty string variable.
* Act: Call LpsRec with the empty string.
* Assert: Assert that the function returns 0.

**Validation:**

* The assertion verifies that the function correctly handles the base case of an empty string.
* This test is important because it ensures that the function doesn't crash or return unexpected results for invalid input.

### Scenario 2: Single Character String

**Details:**

* Description: Check if the function correctly identifies the longest palindromic substring for a single-character string.
* Target scenario: The function should return 1 for a single-character string.

**Execution:**

* Arrange: Create a string variable with a single character.
* Act: Call LpsRec with the single-character string.
* Assert: Assert that the function returns 1.

**Validation:**

* The assertion verifies that the function correctly handles the base case of a single-character string.
* This test is important because it ensures that the function correctly identifies palindromes of length 1.

### Scenario 3: Palindrome String

**Details:**

* Description: Check if the function correctly identifies the longest palindromic substring for a palindrome string.
* Target scenario: The function should return the length of the entire string for a palindrome string.

**Execution:**

* Arrange: Create a string variable that is a palindrome.
* Act: Call LpsRec with the palindrome string.
* Assert: Assert that the function returns the length of the string.

**Validation:**

* The assertion verifies that the function correctly identifies the entire palindrome string as the longest palindromic substring.
* This test is important because it ensures that the function can handle palindromes of any length.

### Scenario 4: Non-Palindrome String

**Details:**

* Description: Check if the function correctly identifies the longest palindromic substring for a non-palindrome string.
* Target scenario: The function should return the length of the longest palindromic substring within the string.

**Execution:**

* Arrange: Create a string variable that is not a palindrome.
* Act: Call LpsRec with the non-palindrome string.
* Assert: Assert that the function returns the length of the longest palindromic substring within the string.

**Validation:**

* The assertion verifies that the function correctly identifies the longest palindromic substring within the non-palindrome string.
* This test is important because it ensures that the function can handle strings with various palindromic substrings of different lengths.

### Scenario 5: Large String

**Details:**

* Description: Check if the function performs efficiently with a large input string.
* Target scenario: The function should complete within a reasonable time for large input strings.

**Execution:**

* Arrange: Create a string variable with a large number of characters.
* Act: Call LpsRec with the large string.
* Assert: Assert that the function completes within a predefined time limit.

**Validation:**

* The assertion verifies that the function's performance doesn't degrade significantly for large input strings.
* This test is important because it ensures that the function is usable in practical scenarios with large amounts of data.

## Additional Test Scenarios

* Test the function with strings containing special characters and spaces.
* Test the function with strings containing uppercase and lowercase letters.
* Test the function with strings containing non-ASCII characters.
* Test the function with strings containing repeated characters.
* Test the function with strings containing substrings that are palindromes but not the longest palindromic substring.

By creating a comprehensive set of test scenarios, you can ensure that the LpsRec function works correctly under various conditions and provides accurate results for different input strings.

*/

// ********RoostGPT********
package dynamic

import (
	"fmt"
	"os"
	"testing"
)

// Define a test struct to hold test data and expected results
type lpsRecTest struct {
	word     string
	expected int
}

// Table-driven tests for LpsRec function
func TestLpsRec(t *testing.T) {
	// Create test cases
	tests := []lpsRecTest{
		{"", 0},
		{"a", 1},
		{"aba", 3},
		{"babab", 5},
		{"racecar", 7},
		{"abccba", 6},
		{"abacaba", 7},
		{"abcdefghijklmnopqrstuvwxyz", 1},
		{"1234567890", 1},
		{"!@#$%^&*()", 1},
		{"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz", 26},
		{"1234567890!@#$%^&*()", 10},
		{"aA1Bb2Cc3Dd4Ee5Ff6Gg7Hh8Ii9Jj0Kk1Ll2Mm3Nn4Oo5Pp6Qq7Rr8Ss9Tt0Uu1Vv2Ww3Xx4Yy5Zz", 52},
		{"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6", 52},
	}

	// Run tests
	for _, test := range tests {
		t.Run(test.word, func(t *testing.T) {
			// Capture standard output for testing functions that do not return values
			stdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			// Call LpsRec and log the test scenario
			result := LpsRec(test.word)
			t.Logf("Testing LpsRec with word: %s", test.word)

			// Restore standard output
			w.Close()
			os.Stdout = stdout

			// Read the captured output
			var output string
			fmt.Fscanf(r, "%s", &output)

			// Assert that the result is as expected
			if result != test.expected {
				t.Errorf("Expected longest palindromic substring length: %d, got: %d", test.expected, result)
			}
		})
	}
}

// Max function
func Max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// lpsRec function for calculating the longest palindromic subsequence recursively
func lpsRec(word string, i, j int) int {
	if i == j {
		return 1
	}
	if i > j {
		return 0
	}
	if word[i] == word[j] {
		return 2 + lpsRec(word, i+1, j-1)
	}
	return Max(lpsRec(word, i, j-1), lpsRec(word, i+1, j))
}
