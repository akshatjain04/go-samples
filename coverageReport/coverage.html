
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sort: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TheAlgorithms/Go/sort/bogosort.go (30.0%)</option>
				
				<option value="file1">github.com/TheAlgorithms/Go/sqrt/sqrtdecomposition.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// This is a pure Go implementation of the bogosort algorithm,
// also known as permutation sort, stupid sort, slowsort, shotgun sort, or monkey sort.
// Bogosort generates random permutations until it guesses the correct one.

// More info on: https://en.wikipedia.org/wiki/Bogosort

package sort

import (
        "math/rand"

        "github.com/TheAlgorithms/Go/constraints"
)

func isSorted[T constraints.Number](arr []T) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(arr)-1; i++ </span><span class="cov0" title="0">{
                if arr[i] &gt; arr[i+1] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func shuffle[T constraints.Number](arr []T) <span class="cov8" title="1">{
        for i := range arr </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                arr[i], arr[j] = arr[j], arr[i]
        }</span>
}

func Bogo[T constraints.Number](arr []T) []T <span class="cov0" title="0">{
        for !isSorted(arr) </span><span class="cov0" title="0">{
                shuffle(arr)
        }</span>

        <span class="cov0" title="0">return arr</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package sqrt contains algorithms and data structures that contains a âˆšn in their complexity
package sqrt

import "math"

// Sqrt (or Square Root) Decomposition is a technique used for query an array and perform updates
// Inside this package is described its most simple data structure, you can find more at: https://cp-algorithms.com/data_structures/sqrt_decomposition.html
//
// Formally, You can use SqrtDecomposition only if:
//
// Given a function $Query:E_1,...,E_n\rightarrow Q$
//
// if $\exist unionQ:Q,Q\rightarrow Q$
//
// s.t.
//
// - $\forall n\in \N &gt; 1, 1\le i&lt;n, E_1,..., E_n\in E \\ query(E_1,..., E_n)=unionQ(query(E_1,..., E_i), query(E_{i+1},...,E_n))$
//
// - (Only if you want use $update$ function)
// $\forall n\in \N &gt; 0, E_1,..., E_n\in E \\ query(E_1,...,E_{new},..., E_n)=updateQ(query(E_1,...,E_{old},...,E_n), indexof(E_{old}), E_{new})$
type SqrtDecomposition[E any, Q any] struct {
        querySingleElement func(element E) Q
        unionQ             func(q1 Q, q2 Q) Q
        updateQ            func(oldQ Q, oldE E, newE E) (newQ Q)

        elements  []E
        blocks    []Q
        blockSize uint64
}

// Create a new SqrtDecomposition instance with the parameters as specified by SqrtDecomposition comment
// Assumptions:
//   - len(elements) &gt; 0
func NewSqrtDecomposition[E any, Q any](
        elements []E,
        querySingleElement func(element E) Q,
        unionQ func(q1 Q, q2 Q) Q,
        updateQ func(oldQ Q, oldE E, newE E) (newQ Q),
) *SqrtDecomposition[E, Q] <span class="cov8" title="1">{
        sqrtDec := &amp;SqrtDecomposition[E, Q]{
                querySingleElement: querySingleElement,
                unionQ:             unionQ,
                updateQ:            updateQ,
                elements:           elements,
        }
        sqrt := math.Sqrt(float64(len(sqrtDec.elements)))
        blockSize := uint64(sqrt)
        numBlocks := uint64(math.Ceil(float64(len(elements)) / float64(blockSize)))
        sqrtDec.blocks = make([]Q, numBlocks)
        for i := uint64(0); i &lt; uint64(len(elements)); i++ </span><span class="cov8" title="1">{
                if i%blockSize == 0 </span><span class="cov8" title="1">{
                        sqrtDec.blocks[i/blockSize] = sqrtDec.querySingleElement(elements[i])
                }</span> else<span class="cov8" title="1"> {
                        sqrtDec.blocks[i/blockSize] = sqrtDec.unionQ(sqrtDec.blocks[i/blockSize], sqrtDec.querySingleElement(elements[i]))
                }</span>
        }
        <span class="cov8" title="1">sqrtDec.blockSize = blockSize
        return sqrtDec</span>
}

// Performs a query from index start to index end (non included)
// Assumptions:
//   - start &lt; end
//   - start and end are valid
func (s *SqrtDecomposition[E, Q]) Query(start uint64, end uint64) Q <span class="cov8" title="1">{
        firstIndexNextBlock := ((start / s.blockSize) + 1) * s.blockSize
        q := s.querySingleElement(s.elements[start])
        if firstIndexNextBlock &gt; end </span><span class="cov8" title="1">{ // if in same block
                start++
                for start &lt; end </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.querySingleElement(s.elements[start]))
                        start++
                }</span>
        } else<span class="cov8" title="1"> {
                // left side
                start++
                for start &lt; firstIndexNextBlock </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.querySingleElement(s.elements[start]))
                        start++
                }</span>

                //middle part
                <span class="cov8" title="1">endBlock := end / s.blockSize
                for i := firstIndexNextBlock / s.blockSize; i &lt; endBlock; i++ </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.blocks[i])
                }</span>

                // right part
                <span class="cov8" title="1">for i := endBlock * s.blockSize; i &lt; end; i++ </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.querySingleElement(s.elements[i]))
                }</span>
        }
        <span class="cov8" title="1">return q</span>
}

// Assumptions:
//   - index is valid
func (s *SqrtDecomposition[E, Q]) Update(index uint64, newElement E) <span class="cov8" title="1">{
        i := index / s.blockSize
        s.blocks[i] = s.updateQ(s.blocks[i], s.elements[index], newElement)
        s.elements[index] = newElement
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
